// bootstrap.go - Bootstrap endpoint for provisioning new dserv boxes
//
// Serves a shell script at GET /setup that bootstraps a clean RPi (or similar)
// into a fully configured dserv data acquisition box.
//
// Usage from a fresh install:
//   curl -sSL http://server/setup | bash
//   curl -sSL http://server/setup?profile=incage | bash
//   curl -sSL http://server/setup?components=dserv,dlsh | bash
//   curl -sSL http://server/setup | bash -s -- --workgroup mylab
//
// Profiles define which components to install. The special "all" profile
// (and the default "incage" profile) installs everything.

package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"runtime"
	"strings"
	"text/template"
)

// BootstrapProfile defines a named set of components to install
type BootstrapProfile struct {
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Components  []string `json:"components"` // component IDs; empty or ["*"] means all
}

// BootstrapConfig holds parameters for generating the bootstrap script
type BootstrapConfig struct {
	ServerURL      string
	DefaultWG      string
	Version        string
	ComponentsJSON string // filtered component list as JSON
	ProfileName    string
}

// Default profiles - can be overridden via profiles.json alongside components.json
var defaultProfiles = []BootstrapProfile{
	{
		Name:        "incage",
		Description: "Full in-cage data acquisition box (dserv + stim2 + dlsh)",
		Components:  []string{"*"},
	},
	{
		Name:        "server",
		Description: "Data server only (dserv + dlsh, no stimulus)",
		Components:  []string{"dserv", "dlsh"},
	},
	{
		Name:        "minimal",
		Description: "Minimal install (dserv + dlsh, agent only)",
		Components:  []string{"dserv", "dlsh"},
	},
}

// getProfiles returns the active profile list.
// For now returns defaults; later can load from a profiles.json file.
func (a *Agent) getProfiles() []BootstrapProfile {
	return defaultProfiles
}

// filterComponents returns the subset of components matching a profile or
// explicit component list. Returns all components if profile is "all" or
// the profile's component list contains "*".
func (a *Agent) filterComponents(profileName string, explicitComponents string) []Component {
	// Explicit component list takes priority
	if explicitComponents != "" {
		wanted := make(map[string]bool)
		for _, id := range strings.Split(explicitComponents, ",") {
			id = strings.TrimSpace(id)
			if id != "" {
				wanted[id] = true
			}
		}
		// Always include dependencies of wanted components
		return a.resolveWithDeps(wanted)
	}

	// Profile lookup
	if profileName == "" || profileName == "all" {
		return a.components
	}

	for _, p := range a.getProfiles() {
		if strings.EqualFold(p.Name, profileName) {
			// "*" means all
			for _, c := range p.Components {
				if c == "*" {
					return a.components
				}
			}
			wanted := make(map[string]bool)
			for _, id := range p.Components {
				wanted[id] = true
			}
			return a.resolveWithDeps(wanted)
		}
	}

	// Unknown profile - return all with a log
	return a.components
}

// resolveWithDeps takes a set of wanted component IDs and adds any
// components they depend on (from the full component list).
func (a *Agent) resolveWithDeps(wanted map[string]bool) []Component {
	// Expand dependencies
	changed := true
	for changed {
		changed = false
		for _, comp := range a.components {
			if !wanted[comp.ID] {
				continue
			}
			for _, dep := range comp.Depends {
				if !wanted[dep] {
					wanted[dep] = true
					changed = true
				}
			}
		}
	}

	// Return in original order
	var result []Component
	for _, comp := range a.components {
		if wanted[comp.ID] {
			result = append(result, comp)
		}
	}
	return result
}

const bootstrapScriptTemplate = `#!/usr/bin/env bash
#
# dserv bootstrap - provision a data acquisition box
#
# Generated by dserv-agent {{.Version}} at {{.ServerURL}}
# Profile: {{.ProfileName}}
#
# Usage:
#   curl -sSL {{.ServerURL}}/setup | bash
#   curl -sSL {{.ServerURL}}/setup | bash -s -- --workgroup mylab
#
set -euo pipefail

# ============ Configuration ============

REGISTRY_URL="{{.ServerURL}}"
DEFAULT_WORKGROUP="{{.DefaultWG}}"
PROFILE="{{.ProfileName}}"
DSERV_INSTALL_DIR="/usr/local/dserv"
LOG_FILE="/tmp/dserv-bootstrap-$(date +%Y%m%d-%H%M%S).log"

# Component definitions (filtered by profile)
COMPONENTS_JSON='{{.ComponentsJSON}}'

# ============ Parse Arguments ============

ROLE=""
WORKGROUP="${DEFAULT_WORKGROUP}"
DRY_RUN=false
SKIP_AGENT=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --role)        ROLE="$2"; shift 2 ;;
        --workgroup)   WORKGROUP="$2"; shift 2 ;;
        --dry-run)     DRY_RUN=true; shift ;;
        --skip-agent)  SKIP_AGENT=true; shift ;;
        --help|-h)
            echo "dserv bootstrap - provision a data acquisition box"
            echo ""
            echo "Usage: curl -sSL ${REGISTRY_URL}/setup | bash -s -- [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --role ROLE          Box role (e.g., eyetracker, stim, control)"
            echo "  --workgroup NAME     Workgroup name (default: ${DEFAULT_WORKGROUP})"
            echo "  --dry-run            Show what would be done without making changes"
            echo "  --skip-agent         Skip dserv-agent install (components only)"
            echo "  --help               Show this help"
            echo ""
            echo "Profiles (set via URL, e.g. /setup?profile=server):"
            echo "  incage    Full in-cage box (all components)"
            echo "  server    Data server only (no stimulus)"
            echo "  minimal   Minimal install (dserv + dlsh)"
            exit 0
            ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

# ============ Helpers ============

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

info()  { echo -e "${BLUE}[info]${NC}  $*"; }
ok()    { echo -e "${GREEN}[ok]${NC}    $*"; }
warn()  { echo -e "${YELLOW}[warn]${NC}  $*"; }
fail()  { echo -e "${RED}[fail]${NC}  $*"; exit 1; }

run() {
    if $DRY_RUN; then
        info "[dry-run] $*"
    else
        "$@" >> "$LOG_FILE" 2>&1
    fi
}

check_not_registry() {
    [[ "${DSERV_BOOTSTRAP_FORCE:-}" == "1" ]] && return 0
    local status
    status=$(curl -sSL "http://localhost/setup/status" 2>/dev/null) || return 0
    if echo "$status" | jq -re '.mode == "server"' &>/dev/null; then
        fail "This appears to be the registry server — aborting. Set DSERV_BOOTSTRAP_FORCE=1 to override."
    fi
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        if command -v sudo &>/dev/null; then
            info "Re-running with sudo..."
            local args=""
            [[ -n "$ROLE" ]]      && args="$args --role $ROLE"
            [[ -n "$WORKGROUP" ]] && args="$args --workgroup $WORKGROUP"
            $DRY_RUN              && args="$args --dry-run"
            $SKIP_AGENT           && args="$args --skip-agent"
            exec sudo bash -c "$(curl -sSL "${REGISTRY_URL}/setup?profile=${PROFILE}")" -- $args
        else
            fail "This script must be run as root"
        fi
    fi
}

# ============ Detection ============

detect_platform() {
    ARCH=$(uname -m)
    case "$ARCH" in
        aarch64|arm64) PLATFORM="arm64" ;;
        armv7l|armhf)  PLATFORM="armhf" ;;
        x86_64)        PLATFORM="amd64" ;;
        *)             PLATFORM="$ARCH" ;;
    esac

    RPI_MODEL=""
    if [[ -f /proc/device-tree/model ]]; then
        RPI_MODEL=$(tr -d '\0' < /proc/device-tree/model)
    fi

    HOSTNAME_VAL=$(hostname)
    IP_ADDR=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "unknown")

    echo ""
    info "Platform:  ${PLATFORM} (${ARCH})"
    info "Hostname:  ${HOSTNAME_VAL}"
    info "IP:        ${IP_ADDR}"
    [[ -n "$RPI_MODEL" ]] && info "Hardware:  ${RPI_MODEL}"
    [[ -n "$ROLE" ]]      && info "Role:      ${ROLE}"
    info "Workgroup: ${WORKGROUP}"
    info "Profile:   ${PROFILE}"
}

# ============ Component Install ============

github_latest_release() {
    local repo="$1"
    curl -sSL "https://api.github.com/repos/${repo}/releases/latest" 2>/dev/null
}

find_asset() {
    local release_json="$1"
    local pattern="$2"
    local arch="$3"

    # Arch-specific match first
    local url
    url=$(echo "$release_json" | jq -r \
        --arg pat "$pattern" --arg arch "$arch" \
        '.assets[] | select(.name | test($pat)) | select(.name | test($arch)) | .browser_download_url' \
        | head -1)

    # Fall back to pattern only (arch-independent assets)
    if [[ -z "$url" || "$url" == "null" ]]; then
        url=$(echo "$release_json" | jq -r \
            --arg pat "$pattern" \
            '.assets[] | select(.name | test($pat)) | .browser_download_url' \
            | head -1)
    fi

    echo "$url"
}

install_component() {
    local comp_json="$1"
    local comp_id=$(echo "$comp_json" | jq -r '.id')
    local comp_name=$(echo "$comp_json" | jq -r '.name')
    local repo=$(echo "$comp_json" | jq -r '.repo // empty')
    local asset_pattern=$(echo "$comp_json" | jq -r '.assetPattern // empty')
    local install_cmd=$(echo "$comp_json" | jq -r '.installCmd // empty')

    if [[ -z "$repo" ]]; then
        warn "${comp_id}: no repo, skipping"
        return 0
    fi

    info "Installing ${comp_name}..."

    local release_json
    release_json=$(github_latest_release "$repo")
    if [[ -z "$release_json" || "$release_json" == "null" ]]; then
        warn "${comp_id}: cannot fetch release from ${repo}"
        return 1
    fi

    local tag=$(echo "$release_json" | jq -r '.tag_name')
    info "  Release: ${tag}"

    if [[ -z "$asset_pattern" ]]; then
        warn "${comp_id}: no assetPattern, skipping"
        return 1
    fi

    local asset_url
    asset_url=$(find_asset "$release_json" "$asset_pattern" "$PLATFORM")

    if [[ -z "$asset_url" || "$asset_url" == "null" ]]; then
        warn "${comp_id}: no asset matching '${asset_pattern}' for ${PLATFORM}"
        return 1
    fi

    local asset_name=$(basename "$asset_url")
    local download_path="/tmp/${asset_name}"

    info "  Downloading ${asset_name}..."
    run curl -sSL -o "$download_path" "$asset_url"

    if [[ -n "$install_cmd" ]]; then
        local expanded="${install_cmd//\{file\}/$download_path}"
        expanded="${expanded//\{version\}/$tag}"
        info "  Custom install..."
        run bash -c "$expanded"
    elif [[ "$asset_name" == *.deb ]]; then
        info "  Installing .deb..."
        run dpkg -i "$download_path" || run apt-get install -f -y -qq
    else
        warn "${comp_id}: no installCmd and not a .deb (${asset_name})"
        rm -f "$download_path"
        return 1
    fi

    rm -f "$download_path"
    ok "${comp_name} ${tag}"
    return 0
}

# ============ Steps ============

step_prerequisites() {
    info "Installing prerequisites..."
    run apt-get update -qq
    run apt-get install -y -qq curl jq ca-certificates
    ok "Prerequisites"
}

step_install_components() {
    local count=$(echo "$COMPONENTS_JSON" | jq '.components | length')
    local names=$(echo "$COMPONENTS_JSON" | jq -r '[.components[].name] | join(", ")')
    info "Components to install: ${names}"

    if [[ "$count" -eq 0 ]]; then
        warn "No components in profile"
        return
    fi

    # Dependency-ordered install
    local -a installed=()
    local -a remaining=()

    for i in $(seq 0 $((count - 1))); do
        remaining+=($i)
    done

    local max_passes=$((count + 1))
    local pass=0

    while [[ ${#remaining[@]} -gt 0 && $pass -lt $max_passes ]]; do
        local progress=false
        local -a next_remaining=()

        for i in "${remaining[@]}"; do
            local comp_json=$(echo "$COMPONENTS_JSON" | jq ".components[$i]")
            local comp_id=$(echo "$comp_json" | jq -r '.id')
            local deps=$(echo "$comp_json" | jq -r '.depends // [] | .[]' 2>/dev/null)

            local deps_met=true
            for dep in $deps; do
                local found=false
                for inst in "${installed[@]+"${installed[@]}"}"; do
                    [[ "$inst" == "$dep" ]] && found=true && break
                done
                $found || { deps_met=false; break; }
            done

            if $deps_met; then
                install_component "$comp_json" && installed+=("$comp_id") || warn "Failed: ${comp_id}"
                progress=true
            else
                next_remaining+=($i)
            fi
        done

        remaining=("${next_remaining[@]+"${next_remaining[@]}"}")
        ((pass++))

        if ! $progress && [[ ${#remaining[@]} -gt 0 ]]; then
            warn "Unresolvable dependencies, installing remaining"
            for i in "${remaining[@]}"; do
                local comp_json=$(echo "$COMPONENTS_JSON" | jq ".components[$i]")
                local comp_id=$(echo "$comp_json" | jq -r '.id')
                install_component "$comp_json" && installed+=("$comp_id") || warn "Failed: ${comp_id}"
            done
            break
        fi
    done

    echo ""
    ok "Installed ${#installed[@]}/${count}: ${installed[*]}"
}

step_install_agent() {
    if $SKIP_AGENT; then
        info "Skipping dserv-agent (--skip-agent)"
        return
    fi

    info "Installing dserv-agent..."

    local release_json
    release_json=$(github_latest_release "SheinbergLab/dserv-agent")
    if [[ -z "$release_json" ]]; then
        warn "Cannot fetch dserv-agent release"
        return
    fi

    local tag=$(echo "$release_json" | jq -r '.tag_name')
    info "  Release: ${tag}"

    local deb_url
    deb_url=$(find_asset "$release_json" "dserv-agent.*\\.deb$" "$PLATFORM")

    if [[ -n "$deb_url" && "$deb_url" != "null" ]]; then
        local deb_file="/tmp/dserv-agent-${tag}.deb"
        run curl -sSL -o "$deb_file" "$deb_url"
        run dpkg -i "$deb_file" || run apt-get install -f -y -qq
        rm -f "$deb_file"
    else
        local bin_url
        bin_url=$(find_asset "$release_json" "dserv-agent.*linux.*${PLATFORM}" "$PLATFORM")
        if [[ -z "$bin_url" || "$bin_url" == "null" ]]; then
            warn "No dserv-agent package for ${PLATFORM}"
            return
        fi
        run curl -sSL -o /usr/local/bin/dserv-agent "$bin_url"
        run chmod +x /usr/local/bin/dserv-agent
    fi

    ok "dserv-agent ${tag}"
}

step_configure_agent() {
    if $SKIP_AGENT; then return; fi

    info "Configuring dserv-agent..."
    mkdir -p /etc/dserv-agent

    cat > /etc/systemd/system/dserv-agent.service <<EOF
[Unit]
Description=dserv management agent
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/bin/dserv-agent \\
    --registry ${REGISTRY_URL} \\
    --workgroup ${WORKGROUP} \\
    --listen 0.0.0.0:80
Restart=always
RestartSec=5
Environment=DSERV_AGENT_TOKEN=

[Install]
WantedBy=multi-user.target
EOF

    run systemctl daemon-reload
    run systemctl enable dserv-agent
    ok "dserv-agent service configured"
}

step_configure_dserv() {
    info "Configuring dserv..."
    mkdir -p "${DSERV_INSTALL_DIR}/etc"

    cat > "${DSERV_INSTALL_DIR}/etc/mesh.conf" <<EOF
# Auto-generated by dserv bootstrap
registry ${REGISTRY_URL}
workgroup ${WORKGROUP}
EOF

    if [[ -n "$ROLE" ]]; then
        cat > "${DSERV_INSTALL_DIR}/etc/role.conf" <<EOF
role ${ROLE}
EOF
        info "  Role: ${ROLE}"
    fi

    ok "dserv configured"
}

step_start_services() {
    info "Starting services..."

    if ! $SKIP_AGENT; then
        run systemctl start dserv-agent || warn "dserv-agent failed to start"
    fi
    run systemctl start dserv || warn "dserv failed to start"

    sleep 2

    if systemctl is-active --quiet dserv 2>/dev/null; then
        ok "dserv running"
    else
        warn "dserv not running (journalctl -u dserv)"
    fi

    if ! $SKIP_AGENT; then
        if systemctl is-active --quiet dserv-agent 2>/dev/null; then
            ok "dserv-agent running"
        else
            warn "dserv-agent not running (journalctl -u dserv-agent)"
        fi
    fi
}

step_verify() {
    info "Verifying registry..."
    local resp
    resp=$(curl -sSL -o /dev/null -w "%{http_code}" \
        "${REGISTRY_URL}/setup/status" 2>/dev/null || echo "000")

    if [[ "$resp" == "200" ]]; then
        ok "Registry reachable"
    else
        warn "Registry not reachable (HTTP ${resp}) - agent will retry"
    fi
}

# ============ Main ============

main() {
    check_not_registry
    check_root

    echo ""
    echo -e "${BOLD}╔══════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║       dserv bootstrap installer          ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════╝${NC}"
    echo -e "  registry:  ${REGISTRY_URL}"
    echo -e "  workgroup: ${WORKGROUP}"
    echo -e "  profile:   ${PROFILE}"
    $DRY_RUN && echo -e "  ${YELLOW}** DRY RUN **${NC}"
    echo ""

    detect_platform

    echo ""
    info "Log: ${LOG_FILE}"
    echo ""

    step_prerequisites
    step_install_components
    step_install_agent
    step_configure_agent
    step_configure_dserv
    step_start_services
    step_verify

    local ip_addr
    ip_addr=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "localhost")

    echo ""
    echo -e "${BOLD}╔══════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║          Bootstrap complete!             ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════╝${NC}"
    echo ""
    ok "Agent UI:  http://${ip_addr}/"
    ok "Mesh:      ${REGISTRY_URL}/w/${WORKGROUP}"
    ok "Log:       ${LOG_FILE}"
    echo ""
}

main "$@"
`

var bootstrapTmpl *template.Template

func init() {
	bootstrapTmpl = template.Must(template.New("bootstrap").Parse(bootstrapScriptTemplate))
}

// GET /setup - serve the bootstrap install script
//
// Query parameters:
//   profile    - named profile (default: "incage")
//   components - explicit comma-separated component IDs (overrides profile)
//   workgroup  - override default workgroup
//   role       - set box role
//
// Examples:
//   curl -sSL http://server/setup | bash              # incage profile (all)
//   curl -sSL http://server/setup?profile=server | bash
//   curl -sSL http://server/setup?components=dserv,dlsh | bash
func (a *Agent) handleBootstrap(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	scheme := "http"
	if r.TLS != nil || r.Header.Get("X-Forwarded-Proto") == "https" {
		scheme = "https"
	}
	host := r.Host
	if host == "" {
		host = r.Header.Get("Host")
	}
	serverURL := fmt.Sprintf("%s://%s", scheme, host)

	workgroup := r.URL.Query().Get("workgroup")
	if workgroup == "" {
		workgroup = a.cfg.Workgroup
	}

	profileName := r.URL.Query().Get("profile")
	if profileName == "" {
		profileName = "incage"
	}
	explicitComponents := r.URL.Query().Get("components")

	// Filter components based on profile or explicit list
	components := a.filterComponents(profileName, explicitComponents)

	compJSON, _ := json.Marshal(struct {
		Components []Component `json:"components"`
	}{Components: components})

	cfg := BootstrapConfig{
		ServerURL:      serverURL,
		DefaultWG:      workgroup,
		Version:        version,
		ComponentsJSON: string(compJSON),
		ProfileName:    profileName,
	}

	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	w.Header().Set("Content-Disposition", "inline; filename=\"dserv-setup.sh\"")

	if err := bootstrapTmpl.Execute(w, cfg); err != nil {
		http.Error(w, "Template error: "+err.Error(), 500)
	}
}

// GET /setup/status - health check for bootstrap script verification
func (a *Agent) handleBootstrapStatus(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, 200, map[string]interface{}{
		"ok":       true,
		"version":  version,
		"mode":     "server",
		"platform": runtime.GOOS + "/" + runtime.GOARCH,
	})
}

// GET /setup/profiles - list available profiles
func (a *Agent) handleBootstrapProfiles(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, 200, map[string]interface{}{
		"profiles": a.getProfiles(),
	})
}

// registerBootstrapHandlers adds bootstrap endpoints to the mux.
// No auth required — fresh boxes need bare curl access.
func registerBootstrapHandlers(mux *http.ServeMux, agent *Agent) {
	mux.HandleFunc("/setup", agent.handleBootstrap)
	mux.HandleFunc("/setup/status", agent.handleBootstrapStatus)
	mux.HandleFunc("/setup/profiles", agent.handleBootstrapProfiles)

	mux.HandleFunc("/setup/", func(w http.ResponseWriter, r *http.Request) {
		path := strings.TrimPrefix(r.URL.Path, "/setup")
		path = strings.TrimPrefix(path, "/")
		switch path {
		case "", "index.sh":
			agent.handleBootstrap(w, r)
		case "status":
			agent.handleBootstrapStatus(w, r)
		case "profiles":
			agent.handleBootstrapProfiles(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}
