// bootstrap.go - Bootstrap endpoint for provisioning new dserv boxes
//
// Serves a shell script at GET /setup that bootstraps a clean RPi (or similar)
// into a fully configured dserv data acquisition box.
//
// Usage from a fresh install:
//   curl -sSL http://server/setup | bash
//   curl -sSL http://server/setup | bash -s -- --role eyetracker --workgroup mylab
//
// The script is dynamically generated so it always points back to the
// correct registry server and can embed workgroup-specific configuration.

package main

import (
	"fmt"
	"net/http"
	"runtime"
	"strings"
	"text/template"
)

// BootstrapConfig holds parameters for generating the bootstrap script
type BootstrapConfig struct {
	ServerURL     string // URL of this registry server
	DefaultWG     string // Default workgroup (from query param or server config)
	Role          string // Optional role hint
	Version       string // Agent version for display
	Components    []Component
}

const bootstrapScriptTemplate = `#!/usr/bin/env bash
#
# dserv bootstrap - provision a data acquisition box
#
# Generated by dserv-agent {{.Version}} at {{.ServerURL}}
#
# Usage:
#   curl -sSL {{.ServerURL}}/setup | bash
#   curl -sSL {{.ServerURL}}/setup | bash -s -- --role eyetracker --workgroup mylab
#
set -euo pipefail

# ============ Configuration ============

REGISTRY_URL="{{.ServerURL}}"
DEFAULT_WORKGROUP="{{.DefaultWG}}"
DSERV_INSTALL_DIR="/usr/local/dserv"
AGENT_SERVICE="dserv-agent"
DSERV_SERVICE="dserv"
LOG_FILE="/tmp/dserv-bootstrap-$(date +%Y%m%d-%H%M%S).log"

# ============ Parse Arguments ============

ROLE=""
WORKGROUP="${DEFAULT_WORKGROUP}"
DRY_RUN=false
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --role)       ROLE="$2"; shift 2 ;;
        --workgroup)  WORKGROUP="$2"; shift 2 ;;
        --dry-run)    DRY_RUN=true; shift ;;
        --verbose)    VERBOSE=true; shift ;;
        --help|-h)
            echo "dserv bootstrap - provision a data acquisition box"
            echo ""
            echo "Usage: curl -sSL ${REGISTRY_URL}/setup | bash -s -- [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --role ROLE          Box role (e.g., eyetracker, stim, control)"
            echo "  --workgroup NAME     Workgroup name (default: ${DEFAULT_WORKGROUP})"
            echo "  --dry-run            Show what would be done without making changes"
            echo "  --verbose            Show detailed output"
            echo "  --help               Show this help"
            exit 0
            ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

# ============ Helpers ============

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

info()  { echo -e "${BLUE}[info]${NC}  $*"; }
ok()    { echo -e "${GREEN}[ok]${NC}    $*"; }
warn()  { echo -e "${YELLOW}[warn]${NC}  $*"; }
fail()  { echo -e "${RED}[fail]${NC}  $*"; exit 1; }

run() {
    if $DRY_RUN; then
        info "[dry-run] $*"
    else
        "$@" >> "$LOG_FILE" 2>&1
    fi
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        if command -v sudo &>/dev/null; then
            info "Re-running with sudo..."
            exec sudo bash "$0" "$@"
        else
            fail "This script must be run as root"
        fi
    fi
}

# ============ Detection ============

detect_platform() {
    ARCH=$(uname -m)
    case "$ARCH" in
        aarch64|arm64) PLATFORM="arm64" ;;
        armv7l|armhf)  PLATFORM="armhf" ;;
        x86_64)        PLATFORM="amd64" ;;
        *)             PLATFORM="$ARCH" ;;
    esac

    # Detect RPi model
    RPI_MODEL=""
    if [[ -f /proc/device-tree/model ]]; then
        RPI_MODEL=$(tr -d '\0' < /proc/device-tree/model)
    fi

    HOSTNAME=$(hostname)
    MAC=""
    # Get primary interface MAC
    for iface in eth0 wlan0 end0; do
        if [[ -f "/sys/class/net/${iface}/address" ]]; then
            MAC=$(cat "/sys/class/net/${iface}/address")
            break
        fi
    done

    IP=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "unknown")

    info "Platform:  ${PLATFORM}"
    info "Hostname:  ${HOSTNAME}"
    info "IP:        ${IP}"
    [[ -n "$MAC" ]]       && info "MAC:       ${MAC}"
    [[ -n "$RPI_MODEL" ]] && info "Hardware:  ${RPI_MODEL}"
    [[ -n "$ROLE" ]]      && info "Role:      ${ROLE}"
    info "Workgroup: ${WORKGROUP}"
}

# ============ Steps ============

step_prerequisites() {
    info "Installing prerequisites..."
    run apt-get update -qq
    run apt-get install -y -qq curl wget jq apt-transport-https ca-certificates
    ok "Prerequisites installed"
}

step_install_dserv() {
    info "Installing dserv..."

    # Fetch latest release info from GitHub
    local release_url="https://api.github.com/repos/SheinbergLab/dserv/releases/latest"
    local release_json
    release_json=$(curl -sSL "$release_url") || fail "Cannot reach GitHub API"

    local tag=$(echo "$release_json" | jq -r '.tag_name')
    info "Latest release: ${tag}"

    # Find the right .deb asset for this platform
    local deb_pattern
    case "$PLATFORM" in
        arm64) deb_pattern="arm64\\.deb" ;;
        armhf) deb_pattern="armhf\\.deb" ;;
        amd64) deb_pattern="amd64\\.deb" ;;
        *)     fail "No prebuilt package for platform: ${PLATFORM}" ;;
    esac

    local deb_url
    deb_url=$(echo "$release_json" | jq -r ".assets[] | select(.name | test(\"${deb_pattern}\")) | .browser_download_url" | head -1)

    if [[ -z "$deb_url" || "$deb_url" == "null" ]]; then
        fail "No .deb package found for ${PLATFORM} in release ${tag}"
    fi

    local deb_file="/tmp/dserv-${tag}-${PLATFORM}.deb"
    info "Downloading ${deb_url}..."
    run curl -sSL -o "$deb_file" "$deb_url"
    run dpkg -i "$deb_file" || run apt-get install -f -y -qq
    rm -f "$deb_file"

    ok "dserv ${tag} installed"
}

step_install_agent() {
    info "Installing dserv-agent..."

    local release_url="https://api.github.com/repos/SheinbergLab/dserv-agent/releases/latest"
    local release_json
    release_json=$(curl -sSL "$release_url") || fail "Cannot reach GitHub API"

    local tag=$(echo "$release_json" | jq -r '.tag_name')
    info "Latest release: ${tag}"

    # dserv-agent is a single Go binary - find the right one
    local bin_pattern
    case "$PLATFORM" in
        arm64) bin_pattern="linux.*arm64" ;;
        armhf) bin_pattern="linux.*arm" ;;
        amd64) bin_pattern="linux.*amd64" ;;
        *)     fail "No prebuilt binary for platform: ${PLATFORM}" ;;
    esac

    local bin_url
    bin_url=$(echo "$release_json" | jq -r ".assets[] | select(.name | test(\"${bin_pattern}\")) | .browser_download_url" | head -1)

    if [[ -z "$bin_url" || "$bin_url" == "null" ]]; then
        # Fall back to .deb if available
        local deb_pattern="${PLATFORM}\\.deb"
        bin_url=$(echo "$release_json" | jq -r ".assets[] | select(.name | test(\"${deb_pattern}\")) | .browser_download_url" | head -1)
        if [[ -n "$bin_url" && "$bin_url" != "null" ]]; then
            local deb_file="/tmp/dserv-agent-${tag}.deb"
            run curl -sSL -o "$deb_file" "$bin_url"
            run dpkg -i "$deb_file"
            rm -f "$deb_file"
            ok "dserv-agent ${tag} installed (deb)"
            return
        fi
        fail "No binary found for ${PLATFORM} in release ${tag}"
    fi

    run curl -sSL -o /usr/local/bin/dserv-agent "$bin_url"
    run chmod +x /usr/local/bin/dserv-agent

    ok "dserv-agent ${tag} installed"
}

step_configure_agent() {
    info "Configuring dserv-agent..."

    mkdir -p /etc/dserv-agent

    # Create systemd service
    cat > /etc/systemd/system/dserv-agent.service <<EOF
[Unit]
Description=dserv management agent
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/bin/dserv-agent \\
    --registry ${REGISTRY_URL} \\
    --workgroup ${WORKGROUP} \\
    --listen 0.0.0.0:80
Restart=always
RestartSec=5
Environment=DSERV_AGENT_TOKEN=

[Install]
WantedBy=multi-user.target
EOF

    run systemctl daemon-reload
    run systemctl enable dserv-agent

    ok "dserv-agent configured (registry: ${REGISTRY_URL}, workgroup: ${WORKGROUP})"
}

step_configure_dserv() {
    info "Configuring dserv..."

    mkdir -p "${DSERV_INSTALL_DIR}/etc"

    # Write mesh config so dserv heartbeats to registry
    cat > "${DSERV_INSTALL_DIR}/etc/mesh.conf" <<EOF
# Auto-generated by dserv bootstrap
registry ${REGISTRY_URL}
workgroup ${WORKGROUP}
EOF

    # Role-specific configuration
    if [[ -n "$ROLE" ]]; then
        info "Applying role configuration: ${ROLE}"
        cat > "${DSERV_INSTALL_DIR}/etc/role.conf" <<EOF
# Box role set by bootstrap
role ${ROLE}
EOF
    fi

    ok "dserv configured"
}

step_start_services() {
    info "Starting services..."
    run systemctl start dserv-agent || warn "dserv-agent failed to start (check journalctl -u dserv-agent)"
    run systemctl start dserv       || warn "dserv failed to start (check journalctl -u dserv)"
    ok "Services started"
}

step_register() {
    info "Registering with registry..."

    # Give agent a moment to start
    sleep 2

    # The agent will heartbeat automatically, but let's verify connectivity
    local resp
    resp=$(curl -sSL -o /dev/null -w "%{http_code}" "${REGISTRY_URL}/api/registry/status" 2>/dev/null || echo "000")

    if [[ "$resp" == "200" ]]; then
        ok "Registry reachable at ${REGISTRY_URL}"
    else
        warn "Registry not reachable (HTTP ${resp}) - agent will retry automatically"
    fi
}

# ============ Main ============

main() {
    echo ""
    echo "╔══════════════════════════════════════╗"
    echo "║       dserv bootstrap installer      ║"
    echo "║                                      ║"
    echo "║  registry: ${REGISTRY_URL}$(printf '%*s' $((22 - ${#REGISTRY_URL})) '')║"
    echo "╚══════════════════════════════════════╝"
    echo ""

    check_root

    detect_platform

    echo ""
    info "Bootstrap log: ${LOG_FILE}"
    echo ""

    step_prerequisites
    step_install_dserv
    step_install_agent
    step_configure_agent
    step_configure_dserv
    step_start_services
    step_register

    echo ""
    echo "╔══════════════════════════════════════╗"
    echo "║          Bootstrap complete!         ║"
    echo "╚══════════════════════════════════════╝"
    echo ""
    ok "dserv agent UI:  http://${IP}/"
    ok "Registry:        ${REGISTRY_URL}/w/${WORKGROUP}"
    ok "Log file:        ${LOG_FILE}"
    echo ""
}

main
`

var bootstrapTmpl *template.Template

func init() {
	bootstrapTmpl = template.Must(template.New("bootstrap").Parse(bootstrapScriptTemplate))
}

// GET /setup - serve the bootstrap install script
//
// Query parameters:
//   workgroup - override default workgroup
//   role      - set box role
//
// Example:
//   curl -sSL http://server/setup | bash
//   curl -sSL http://server/setup?workgroup=mylab | bash
//   curl -sSL http://server/setup?workgroup=mylab&role=eyetracker | bash
func (a *Agent) handleBootstrap(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Determine the server's own URL
	scheme := "http"
	if r.TLS != nil || r.Header.Get("X-Forwarded-Proto") == "https" {
		scheme = "https"
	}
	host := r.Host
	if host == "" {
		host = r.Header.Get("Host")
	}
	serverURL := fmt.Sprintf("%s://%s", scheme, host)

	// Allow query param overrides
	workgroup := r.URL.Query().Get("workgroup")
	if workgroup == "" {
		workgroup = a.cfg.Workgroup
	}
	role := r.URL.Query().Get("role")

	cfg := BootstrapConfig{
		ServerURL:  serverURL,
		DefaultWG:  workgroup,
		Role:       role,
		Version:    version,
		Components: a.components,
	}

	w.Header().Set("Content-Type", "text/plain; charset=utf-8")
	// Hint to curl that this is a script
	w.Header().Set("Content-Disposition", "inline; filename=\"dserv-setup.sh\"")

	if err := bootstrapTmpl.Execute(w, cfg); err != nil {
		http.Error(w, "Template error: "+err.Error(), 500)
	}
}

// GET /setup/status - quick JSON endpoint for the bootstrap script to verify connectivity
func (a *Agent) handleBootstrapStatus(w http.ResponseWriter, r *http.Request) {
	writeJSON(w, 200, map[string]interface{}{
		"ok":       true,
		"version":  version,
		"mode":     "server",
		"platform": runtime.GOOS + "/" + runtime.GOARCH,
	})
}

// registerBootstrapHandlers adds bootstrap endpoints to the mux.
// Called in server mode only, no auth required (the script needs to be
// fetchable from a bare curl on a fresh box).
func registerBootstrapHandlers(mux *http.ServeMux, agent *Agent) {
	mux.HandleFunc("/setup", agent.handleBootstrap)
	mux.HandleFunc("/setup/status", agent.handleBootstrapStatus)

	// Also handle with trailing slash
	mux.HandleFunc("/setup/", func(w http.ResponseWriter, r *http.Request) {
		path := strings.TrimPrefix(r.URL.Path, "/setup")
		path = strings.TrimPrefix(path, "/")
		switch path {
		case "", "index.sh":
			agent.handleBootstrap(w, r)
		case "status":
			agent.handleBootstrapStatus(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}
