<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dserv Console</title>
    <style>
/* Reset and base styles */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    background: #1e1e1e;
    color: #d4d4d4;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Header */
#header {
    background: #2d2d30;
    padding: 10px 20px;
    border-bottom: 1px solid #3e3e42;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.header-left {
    display: flex;
    align-items: center;
    gap: 16px;
}

.header-right {
    display: flex;
    align-items: center;
    gap: 12px;
}

#header h1 {
    font-size: 16px;
    font-weight: normal;
    color: #cccccc;
}

.status {
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 3px;
    background: #0e639c;
    color: white;
    transition: background 0.3s;
}

.status.disconnected {
    background: #a1260d;
}

/* Main content - split panes */
#main-content {
    flex: 1;
    display: flex;
    min-height: 0;
    position: relative;
}

.pane {
    display: flex;
    flex-direction: column;
    min-width: 300px;
    overflow: hidden;
}

#terminal-pane {
    flex: 1;
    background: #1e1e1e;
}

#datapoint-pane {
    width: 400px;
    background: #252526;
    border-left: 1px solid #3e3e42;
    display: flex;
    flex-direction: column;
}

/* Resize handle */
#resize-handle {
    width: 5px;
    background: #3e3e42;
    cursor: col-resize;
    position: relative;
    flex-shrink: 0;
}

#resize-handle:hover {
    background: #0e639c;
}

#resize-handle:active {
    background: #1177bb;
}

/* Pane headers */
.pane-header {
    background: #2d2d30;
    padding: 8px 12px;
    border-bottom: 1px solid #3e3e42;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.pane-title {
    font-size: 13px;
    font-weight: 600;
    color: #cccccc;
}

.pane-tabs {
    display: flex;
    gap: 4px;
}

.pane-tab {
    background: transparent;
    color: #cccccc;
    border: none;
    border-bottom: 2px solid transparent;
    padding: 4px 12px;
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.pane-tab:hover {
    color: #cccccc;
    background: rgba(255, 255, 255, 0.05);
}

.pane-tab.active {
    color: #007acc;
    border-bottom-color: #007acc;
}

.tab-badge {
    display: inline-block;
    background: #d32f2f;
    color: white;
    font-size: 9px;
    font-weight: 600;
    padding: 2px 5px;
    border-radius: 10px;
    margin-left: 6px;
    min-width: 16px;
    text-align: center;
}

.tab-badge.hidden {
    display: none;
}

.pane-tab.active .tab-badge {
    display: none;
}

.pane-controls {
    display: flex;
    gap: 8px;
    align-items: center;
}

/* Interpreter selector */
.interp-selector {
    background: #1e1e1e;
    color: #d4d4d4;
    border: 1px solid #3e3e42;
    border-radius: 3px;
    padding: 4px 8px;
    font-size: 12px;
    font-family: inherit;
    cursor: pointer;
    outline: none;
    transition: all 0.2s;
}

.interp-selector:hover {
    background: #2d2d30;
    border-color: #569cd6;
}

.interp-selector:focus {
    border-color: #0e639c;
    box-shadow: 0 0 0 1px #0e639c;
}

.icon-btn {
    background: #3c3c3c;
    border: 1px solid #3e3e42;
    color: #cccccc;
    padding: 4px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 11px;
    font-family: inherit;
    transition: all 0.2s;
}

.icon-btn:hover {
    background: #4a4a4a;
    border-color: #569cd6;
}

.update-count {
    font-size: 11px;
    color: #858585;
}

/* Terminal styles */
.terminal-output {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    font-size: 14px;
    line-height: 1.5;
}

.output-line {
    margin: 2px 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    user-select: text;
    cursor: text;
}

.command-line {
    color: #569cd6;
}

.result-line {
    color: #d4d4d4;
}

.error-line {
    color: #f48771;
}

.info-line {
    color: #608b4e;
    font-style: italic;
}

.warning-line {
    color: #dcdcaa;
}

.input-container {
    display: flex;
    align-items: center;
    margin-top: 4px;
}

.prompt {
    color: #569cd6;
    margin-right: 8px;
    user-select: none;
}

#terminal input {
    flex: 1;
    background: transparent;
    border: none;
    color: #d4d4d4;
    font-family: inherit;
    font-size: inherit;
    outline: none;
    caret-color: #d4d4d4;
}

#terminal input::selection {
    background: #264f78;
}

/* Datapoint list */
#datapoint-list-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    border-bottom: 1px solid #3e3e42;
}

.search-container {
    padding: 8px 12px;
    background: #252526;
    border-bottom: 1px solid #3e3e42;
    position: relative;
    flex-shrink: 0;
}

.search-input {
    width: 100%;
    padding: 6px 24px 6px 10px;
    border: 1px solid #3e3e42;
    border-radius: 3px;
    font-size: 12px;
    background: #1e1e1e;
    color: #d4d4d4;
    font-family: inherit;
}

.search-input:focus {
    outline: none;
    border-color: #0e639c;
    box-shadow: 0 0 0 1px #0e639c;
}

.search-clear {
    position: absolute;
    right: 22px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: #858585;
    cursor: pointer;
    font-size: 16px;
    padding: 0;
    width: 20px;
    height: 20px;
    display: none;
}

.search-clear:hover {
    color: #cccccc;
}

.datapoint-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
}

.datapoint-item {
    padding: 6px 8px;
    margin: 2px 0;
    background: #2d2d30;
    border: 1px solid #3e3e42;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    font-size: 12px;
}

.datapoint-item:hover {
    background: #37373d;
    border-color: #0e639c;
    transform: translateX(2px);
}

.datapoint-item.selected {
    background: #094771;
    border-color: #0e639c;
}

.datapoint-item.subscribed {
    background: #1a3d1a;
    border-color: #4caf50;
}

.datapoint-item.subscribed::after {
    content: 'üëÅ';
    position: absolute;
    right: 6px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 10px;
}

.datapoint-item.subscribed::before {
    content: '√ó';
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 14px;
    color: #f48771;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s;
    font-weight: bold;
}

.datapoint-item.subscribed:hover::before {
    opacity: 1;
}

/* Datapoint detail */
#datapoint-detail-container {
    height: 300px;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.datapoint-detail {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
    font-size: 12px;
}

.placeholder {
    color: #858585;
    font-style: italic;
    text-align: center;
    padding: 20px;
}

.detail-row {
    margin-bottom: 12px;
}

.detail-label {
    font-weight: 600;
    color: #569cd6;
    margin-bottom: 4px;
}

.detail-value {
    color: #d4d4d4;
    background: #1e1e1e;
    padding: 8px;
    border-radius: 3px;
    border: 1px solid #3e3e42;
    font-family: inherit;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 200px;
    overflow-y: auto;
}

.update-history {
    margin-top: 8px;
    max-height: 200px;
    overflow-y: auto;
}

.update-entry {
    background: #1e1e1e;
    padding: 6px 8px;
    margin: 4px 0;
    border-radius: 3px;
    border-left: 3px solid #0e639c;
    font-size: 11px;
}

.update-time {
    color: #858585;
    font-size: 10px;
    margin-bottom: 2px;
}

/* Control panel */
#control-panel {
    background: #252526;
    padding: 10px 15px;
    border-top: 1px solid #3e3e42;
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
    font-size: 12px;
    flex-shrink: 0;
}

.control-group {
    display: flex;
    gap: 6px;
    align-items: center;
}

.control-group label {
    font-weight: 600;
    color: #cccccc;
    font-size: 11px;
}

.control-group input {
    padding: 4px 8px;
    border: 1px solid #3e3e42;
    border-radius: 3px;
    font-size: 11px;
    background: #1e1e1e;
    color: #d4d4d4;
    font-family: inherit;
    width: 120px;
}

.control-group input:focus {
    outline: none;
    border-color: #0e639c;
}

.control-group button {
    padding: 5px 10px;
    background: #0e639c;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    transition: background 0.2s;
    font-size: 11px;
}

.control-group button:hover {
    background: #1177bb;
}

.control-group button:disabled {
    background: #3e3e42;
    cursor: not-allowed;
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

::-webkit-scrollbar-track {
    background: #1e1e1e;
}

::-webkit-scrollbar-thumb {
    background: #424242;
    border-radius: 5px;
}

::-webkit-scrollbar-thumb:hover {
    background: #4a4a4a;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
    #datapoint-pane {
        width: 350px;
    }
}

@media (max-width: 900px) {
    #main-content {
        flex-direction: column;
    }
    
    #datapoint-pane {
        width: 100%;
        height: 50%;
        border-left: none;
        border-top: 1px solid #3e3e42;
    }
    
    #resize-handle {
        display: none;
    }
}

/* Additional styles for error monitoring */

/* Error Badge in Header */
.error-badge {
    display: flex;
    align-items: center;
    gap: 6px;
    background: #d32f2f;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 12px;
    font-family: inherit;
    transition: all 0.3s;
    margin-right: 12px;
}

.error-badge:hover {
    background: #f44336;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(211, 47, 47, 0.4);
}

.error-badge.hidden {
    display: none;
}

.error-badge.has-unread {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.error-icon {
    font-size: 16px;
}

.error-count {
    background: rgba(255, 255, 255, 0.2);
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 11px;
    font-weight: bold;
    min-width: 20px;
    text-align: center;
}

/* Error Panel */
.error-panel {
    position: fixed;
    top: 60px;
    right: 20px;
    width: 500px;
    max-height: 70vh;
    background: #2d2d30;
    border: 1px solid #d32f2f;
    border-radius: 6px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    display: flex;
    flex-direction: column;
    z-index: 1000;
    overflow: hidden;
}

.error-panel.hidden {
    display: none;
}

.error-panel-header {
    background: #d32f2f;
    color: white;
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #b71c1c;
}

.error-panel-title {
    font-weight: 600;
    font-size: 13px;
}

.error-panel-controls {
    display: flex;
    gap: 8px;
}

.error-panel-controls .icon-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 4px 8px;
    font-size: 12px;
}

.error-panel-controls .icon-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.4);
}

/* Error List */
.error-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    background: #1e1e1e;
}

.error-item {
    background: #2d2d30;
    border: 1px solid #d32f2f;
    border-left: 4px solid #d32f2f;
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 10px;
    transition: all 0.2s;
}

.error-item:hover {
    background: #37373d;
    border-color: #f44336;
    transform: translateX(-2px);
    box-shadow: 2px 0 8px rgba(211, 47, 47, 0.3);
}

.error-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid #3e3e42;
}

.error-interp {
    font-weight: 600;
    color: #f48771;
    font-size: 12px;
}

.error-time {
    font-size: 10px;
    color: #858585;
}

.error-item-body {
    font-size: 11px;
}

.error-info {
    background: #1e1e1e;
    padding: 8px;
    border-radius: 3px;
    color: #f48771;
    overflow-x: auto;
    margin: 6px 0;
    font-family: inherit;
    font-size: 11px;
    line-height: 1.4;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.error-command,
.error-code {
    margin-top: 6px;
    font-size: 10px;
    color: #858585;
}

.error-command code,
.error-code code {
    background: #1e1e1e;
    padding: 2px 6px;
    border-radius: 2px;
    color: #dcdcaa;
}

/* Error Notification (Toast) */
.error-notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 350px;
    background: #2d2d30;
    border: 2px solid #d32f2f;
    border-radius: 6px;
    padding: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    z-index: 2000;
    cursor: pointer;
    animation: slideIn 0.3s ease-out;
    transition: opacity 0.3s;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.error-notification.fade-out {
    opacity: 0;
    transform: translateX(400px);
}

.error-notification:hover {
    border-color: #f44336;
    box-shadow: 0 6px 24px rgba(211, 47, 47, 0.4);
}

.error-notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    color: #f48771;
    font-size: 12px;
}

.error-notification-time {
    font-size: 10px;
    color: #858585;
}

.error-notification-body {
    color: #d4d4d4;
    font-size: 11px;
    line-height: 1.4;
    max-height: 60px;
    overflow: hidden;
}

/* Responsive adjustments for error panel */
@media (max-width: 768px) {
    .error-panel {
        left: 10px;
        right: 10px;
        width: auto;
        max-height: 60vh;
    }
    
    .error-notification {
        left: 10px;
        right: 10px;
        width: auto;
    }
}
/* Additional CSS for horizontal split layout with error log panel */
/* Add these styles to your existing styles.css */

/* Main content with left pane */
#left-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 400px;
    overflow: hidden;
}

/* Sub-panes within left pane */
.sub-pane {
    display: flex;
    flex-direction: column;
    min-height: 100px;
    overflow: hidden;
}

#terminal-pane {
    flex: 3;
    background: #1e1e1e;
    min-height: 150px;
}

#error-log-pane {
    flex: 1;
    min-height: 100px;
    background: #1e1e1e;
    border-top: 1px solid #3e3e42;
}

/* Resize handles */
.resize-handle {
    flex-shrink: 0;
    position: relative;
}

.resize-handle.horizontal {
    height: 5px;
    width: 100%;
    background: #3e3e42;
    cursor: row-resize;
}

.resize-handle.vertical {
    width: 5px;
    background: #3e3e42;
    cursor: col-resize;
}

.resize-handle:hover {
    background: #0e639c;
}

.resize-handle:active {
    background: #1177bb;
}

/* Legacy support - rename old resize-handle ID */
#vertical-resize-handle {
    width: 5px;
    background: #3e3e42;
    cursor: col-resize;
}

/* Error Log List */
.error-log-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    font-size: 11px;
    display: none;
}

.error-log-list.active {
    display: block;
}

.error-log-item {
    background: #2d2d30;
    border: 1px solid #3e3e42;
    border-left: 4px solid #d32f2f;
    border-radius: 3px;
    padding: 4px 8px;
    margin-bottom: 4px;
    transition: all 0.2s;
    cursor: pointer;
}

.console-log-item {
    background: #2d2d30;
    border: 1px solid #3e3e42;
    border-left: 4px solid #007acc;
    border-radius: 3px;
    padding: 6px 8px;
    margin-bottom: 4px;
    font-family: inherit;
    font-size: 11px;
    line-height: 1.4;
}

.console-block {
    background: #2d2d30;
    border: 1px solid #3e3e42;
    border-radius: 3px;
    margin-bottom: 8px;
    overflow: hidden;
}

.console-block-header {
    background: rgba(0, 0, 0, 0.2);
    padding: 4px 8px;
    display: flex;
    align-items: center;
    gap: 8px;
    border-bottom: 1px solid #3e3e42;
}

.console-block-content {
    padding: 8px;
    margin: 0;
    font-family: inherit;
    font-size: 11px;
    line-height: 1.4;
    color: #d4d4d4;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-x: auto;
}

.console-active-indicator {
    font-size: 10px;
    margin-left: auto;
}

.error-log-item:hover {
    background: #37373d;
    border-color: #f44336;
}

.error-log-item-header {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 10px;
}

/* Arrow indicator inline */
.error-log-item-header::before {
    content: '‚ñº';
    font-size: 8px;
    color: #858585;
    transition: transform 0.2s;
    flex-shrink: 0;
}

.error-log-item.collapsed .error-log-item-header::before {
    transform: rotate(-90deg);
}

.error-log-interp {
    font-weight: 600;
    color: #f48771;
    min-width: 60px;
    flex-shrink: 0;
}

.console-log-interp {
    font-weight: 600;
    margin-right: 8px;
}

.console-log-time {
    font-size: 9px;
    color: #858585;
    margin-right: 8px;
}

.console-log-message {
    color: #d4d4d4;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.error-log-preview {
    flex: 1;
    color: #d4d4d4;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.error-log-time {
    font-size: 9px;
    color: #858585;
    flex-shrink: 0;
}

/* Details section - hidden when collapsed */
.error-log-details {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid #3e3e42;
}

.error-log-item.collapsed .error-log-details {
    display: none;
}

.error-log-info {
    background: #1a1a1a;
    padding: 6px;
    border-radius: 2px;
    color: #f48771;
    overflow-x: auto;
    font-family: inherit;
    font-size: 10px;
    line-height: 1.3;
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 200px;
    overflow-y: auto;
    margin: 0;
}

.error-log-code {
    margin-top: 4px;
    font-size: 9px;
    color: #858585;
}

.error-log-code code {
    background: #1a1a1a;
    padding: 2px 4px;
    border-radius: 2px;
    color: #dcdcaa;
}

/* Error badge - keep existing styles but ensure visibility */
.error-badge {
    display: flex;
    align-items: center;
    gap: 6px;
    background: #d32f2f;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 12px;
    font-family: inherit;
    transition: all 0.3s;
    margin-right: 12px;
}

.error-badge:hover {
    background: #f44336;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(211, 47, 47, 0.4);
}

.error-badge.hidden {
    display: none;
}

.error-icon {
    font-size: 16px;
}

.error-count {
    background: rgba(255, 255, 255, 0.2);
    padding: 2px 6px;
    border-radius: 10px;
    font-size: 11px;
    font-weight: bold;
    min-width: 20px;
    text-align: center;
}

/* Error Notification (Toast) */
.error-notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 350px;
    background: #2d2d30;
    border: 2px solid #d32f2f;
    border-radius: 6px;
    padding: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    z-index: 2000;
    cursor: pointer;
    animation: slideIn 0.3s ease-out;
    transition: opacity 0.3s;
}

@keyframes slideIn {
    from {
        transform: translateX(400px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.error-notification.fade-out {
    opacity: 0;
    transform: translateX(400px);
}

.error-notification:hover {
    border-color: #f44336;
    box-shadow: 0 6px 24px rgba(211, 47, 47, 0.4);
}

.error-notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    color: #f48771;
    font-size: 12px;
    font-weight: 600;
}

.error-notification-time {
    font-size: 10px;
    color: #858585;
    font-weight: normal;
}

.error-notification-body {
    color: #d4d4d4;
    font-size: 11px;
    line-height: 1.4;
    max-height: 60px;
    overflow: hidden;
}

/* Responsive adjustments */
@media (max-width: 900px) {
    #main-content {
        flex-direction: column;
    }
    
    #left-pane {
        width: 100%;
        height: 50%;
    }
    
    #datapoint-pane {
        width: 100%;
        height: 50%;
        border-left: none;
        border-top: 1px solid #3e3e42;
    }
    
    #vertical-resize-handle {
        display: none;
    }
    
    #error-log-pane {
        height: 150px;
    }
}

/* Sandbox Editor Styles */
#sandbox-editor-pane {
    background: #252526;
    border-bottom: 1px solid #3e3e42;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
}

#sandbox-editor-pane.collapsed .sandbox-editor-content,
#sandbox-editor-pane.collapsed .sandbox-status-bar {
    display: none;
}

#sandbox-editor-pane.collapsed .sandbox-editor-header {
    border-bottom: none;
}

.sandbox-editor-header {
    background: #2d2d30;
    padding: 6px 12px;
    border-bottom: 1px solid #3e3e42;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    cursor: pointer;
    user-select: none;
}

.sandbox-editor-header:hover {
    background: #37373d;
}

.sandbox-title-area {
    display: flex;
    align-items: center;
    gap: 8px;
}

.sandbox-toggle {
    font-size: 10px;
    color: #858585;
    transition: transform 0.2s;
}

#sandbox-editor-pane.collapsed .sandbox-toggle {
    transform: rotate(-90deg);
}

.sandbox-editor-title {
    font-size: 13px;
    font-weight: 600;
    color: #cccccc;
}

.sandbox-editor-controls {
    display: flex;
    gap: 6px;
    align-items: center;
}

.sandbox-btn {
    background: #3c3c3c;
    color: #cccccc;
    border: 1px solid #3e3e42;
    padding: 4px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 11px;
    font-family: inherit;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 4px;
}

.sandbox-btn:hover {
    background: #4a4a4a;
    border-color: #569cd6;
}

.sandbox-btn.primary {
    background: #0e639c;
    border-color: #0e639c;
}

.sandbox-btn.primary:hover {
    background: #1177bb;
}

.sandbox-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.sandbox-editor-content {
    display: flex;
    flex-direction: column;
    height: 180px;
    min-height: 80px;
    max-height: 500px;
    overflow: hidden;
}

#sandbox-textarea {
    flex: 1;
    background: #1e1e1e;
    color: #d4d4d4;
    border: none;
    padding: 12px;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.5;
    resize: none;
    outline: none;
    tab-size: 4;
}

#sandbox-textarea::placeholder {
    color: #5a5a5a;
}

#sandbox-textarea:focus {
    background: #1e1e1e;
}

.sandbox-status-bar {
    background: #252526;
    padding: 4px 12px;
    border-top: 1px solid #3e3e42;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 11px;
    color: #858585;
    flex-shrink: 0;
}

.sandbox-status-left {
    display: flex;
    gap: 16px;
}

.sandbox-status-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.sandbox-status-item.error {
    color: #f48771;
}

.sandbox-status-item.warning {
    color: #dcdcaa;
}

.sandbox-status-item.success {
    color: #4ec9b0;
}

.sandbox-lint-popup {
    position: absolute;
    background: #2d2d30;
    border: 1px solid #3e3e42;
    border-radius: 4px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    max-width: 400px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 100;
    font-size: 11px;
}

.sandbox-lint-item {
    padding: 8px 12px;
    border-bottom: 1px solid #3e3e42;
    cursor: pointer;
}

.sandbox-lint-item:last-child {
    border-bottom: none;
}

.sandbox-lint-item:hover {
    background: #37373d;
}

.sandbox-lint-item.error {
    border-left: 3px solid #f48771;
}

.sandbox-lint-item.warning {
    border-left: 3px solid #dcdcaa;
}

.sandbox-lint-location {
    color: #858585;
    font-size: 10px;
    margin-bottom: 2px;
}

.sandbox-lint-message {
    color: #d4d4d4;
}

/* Resize handle between editor and terminal */
#editor-resize-handle {
    height: 4px;
    background: #3e3e42;
    cursor: row-resize;
    flex-shrink: 0;
}

#editor-resize-handle:hover {
    background: #0e639c;
}

#sandbox-editor-pane.collapsed + #editor-resize-handle {
    display: none;
}

    </style>
</head>
<body>
    <!-- Header -->
    <div id="header">
        <div class="header-left">
            <h1>dserv Console</h1>
            <select id="interp-selector" class="interp-selector" title="Select interpreter">
                <option value="dserv">dserv</option>
            </select>
        </div>
        <div class="header-right">
            <!-- Error badge -->
            <button id="error-badge" class="error-badge hidden">
                <span class="error-icon">‚ö†Ô∏è</span>
                <span class="error-count">0</span>
            </button>
            <span id="status" class="status disconnected">Disconnected</span>
        </div>
    </div>

    <!-- Main content area with split panes -->
    <div id="main-content">
        <!-- Left side: Editor + Terminal (top) + Error Log (bottom) -->
        <div id="left-pane" class="pane">
            <!-- Sandbox Editor (collapsible) -->
            <div id="sandbox-editor-pane">
                <div class="sandbox-editor-header" id="sandbox-editor-toggle">
                    <div class="sandbox-title-area">
                        <span class="sandbox-toggle">‚ñº</span>
                        <span class="sandbox-editor-title">Editor</span>
                    </div>
                    <div class="sandbox-editor-controls" onclick="event.stopPropagation()">
                        <button id="sandbox-format-btn" class="sandbox-btn" title="Format code (Mod+Shift+F)">
                            Format
                        </button>
                        <button id="sandbox-lint-btn" class="sandbox-btn" title="Check for errors">
                            Lint
                        </button>
                        <button id="sandbox-clear-btn" class="sandbox-btn" title="Clear editor">
                            Clear
                        </button>
                        <button id="sandbox-execute-btn" class="sandbox-btn primary" title="Execute code (Shift+Enter)">
                            ‚ñ∂ Execute
                        </button>
                    </div>
                </div>
                <div class="sandbox-editor-content">
                    <textarea id="sandbox-textarea" 
                              placeholder="# Paste or write Tcl code here...&#10;# Use Shift+Enter to execute, Mod+Shift+F to format&#10;# Code is sent to the selected interpreter"></textarea>
                </div>
                <div class="sandbox-status-bar">
                    <div class="sandbox-status-left">
                        <span id="sandbox-line-info" class="sandbox-status-item">Ln 1, Col 1</span>
                        <span id="sandbox-lint-status" class="sandbox-status-item success">‚úì Ready</span>
                    </div>
                    <div class="sandbox-status-right">
                        <span id="sandbox-interp-target" class="sandbox-status-item">‚Üí dserv</span>
                    </div>
                </div>
            </div>
            
            <!-- Resize handle between editor and terminal -->
            <div id="editor-resize-handle"></div>

            <!-- Terminal -->
            <div id="terminal-pane" class="sub-pane">
                <div class="pane-header">
                    <span class="pane-title">Terminal</span>
                    <div class="pane-controls">
                        <button id="clear-terminal" class="icon-btn" title="Clear terminal (Ctrl+L)">Clear</button>
                    </div>
                </div>
                <div id="terminal" class="terminal-output"></div>
            </div>

            <!-- Horizontal resize handle -->
            <div id="horizontal-resize-handle" class="resize-handle horizontal"></div>

            <!-- Error Log & Console -->
            <div id="error-log-pane" class="sub-pane">
                <div class="pane-header">
                    <div class="pane-tabs">
                        <button class="pane-tab active" data-tab="errors">
                            Errors
                            <span class="tab-badge hidden" id="errors-badge">0</span>
                        </button>
                        <button class="pane-tab" data-tab="console">
                            Console
                            <span class="tab-badge hidden" id="console-badge">0</span>
                        </button>
                    </div>
                    <div class="pane-controls">
                        <span id="error-log-count" class="update-count">0 errors</span>
                        <button id="clear-error-log" class="icon-btn" title="Clear">Clear</button>
                    </div>
                </div>
                <div id="error-log-list" class="error-log-list active">
                    <div class="placeholder">No errors logged</div>
                </div>
                <div id="console-log-list" class="error-log-list">
                    <div class="placeholder">No console output</div>
                </div>
            </div>
        </div>

        <!-- Vertical resize handle -->
        <div id="vertical-resize-handle" class="resize-handle vertical"></div>

        <!-- Right pane: Datapoint Explorer -->
        <div id="datapoint-pane" class="pane">
            <!-- Top: Datapoint List -->
            <div id="datapoint-list-container">
                <div class="pane-header">
                    <span class="pane-title">Datapoints</span>
                    <div class="pane-controls">
                        <button id="refresh-keys" class="icon-btn" title="Refresh datapoint list">‚ü≥</button>
                        <button id="unsubscribe-all" class="icon-btn" title="Unsubscribe from all">√ó</button>
                    </div>
                </div>
                
                <!-- Search -->
                <div class="search-container">
                    <input type="text" id="search-datapoints" class="search-input" placeholder="Filter datapoints...">
                    <button id="clear-search" class="search-clear">√ó</button>
                </div>
                
                <!-- Datapoint list -->
                <div id="datapoint-list" class="datapoint-list">
                    <div class="placeholder">Connecting...</div>
                </div>
            </div>

            <!-- Bottom: Datapoint Detail -->
            <div id="datapoint-detail-container">
                <div class="pane-header">
                    <span class="pane-title">Details</span>
                    <div class="pane-controls">
                        <span id="update-count" class="update-count">0 updates</span>
                    </div>
                </div>
                <div id="datapoint-detail" class="datapoint-detail">
                    <div class="placeholder">Select a datapoint to view details</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Tcl utilities for sandbox editor -->
    <script src="js/TclFormatter.js"></script>
    <script src="js/TclLinter.js"></script>

    <script>
// ============================================
// WebSocket Manager
// ============================================

class DservWebSocket {
    constructor() {
        this.ws = null;
        this.connected = false;
        this.handlers = new Map();
        this.reconnectTimer = null;
        this.reconnectDelay = 3000;
    }

    on(event, handler) {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, []);
        }
        this.handlers.get(event).push(handler);
    }

    emit(event, data) {
        const handlers = this.handlers.get(event);
        if (handlers) {
            handlers.forEach(handler => handler(data));
        }
    }

    connect() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.hostname}:${window.location.port}/ws`;

        try {
            this.ws = new WebSocket(wsUrl);

            this.ws.onopen = () => {
                this.connected = true;
                this.updateStatus('connected');
                console.log('WebSocket connected');
                this.emit('connected');
                
                // Clear reconnect timer
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }
            };

            this.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.handleMessage(data);
                } catch (e) {
                    console.error('Failed to parse WebSocket message:', e);
                }
            };

            this.ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                this.emit('error', error);
            };

            this.ws.onclose = () => {
                this.connected = false;
                this.updateStatus('disconnected');
                console.log('WebSocket disconnected');
                this.emit('disconnected');
                
                // Auto-reconnect
                if (!this.reconnectTimer) {
                    this.reconnectTimer = setTimeout(() => {
                        console.log('Reconnecting...');
                        this.connect();
                    }, this.reconnectDelay);
                }
            };

        } catch (error) {
            console.error('Failed to connect:', error);
            this.scheduleReconnect();
        }
    }

    scheduleReconnect() {
        if (!this.reconnectTimer) {
            this.reconnectTimer = setTimeout(() => {
                this.connect();
            }, this.reconnectDelay);
        }
    }

    handleMessage(data) {
        // Route messages based on type/cmd
        if (data.result !== undefined || data.status === 'error') {
            // Command response (terminal)
            this.emit('terminal:response', data);
        } else if (data.action === 'subscribed' || data.action === 'unsubscribed') {
            // Subscription confirmation - just acknowledge
            console.log(`Subscription ${data.action}: ${data.match}`);
        } else if (data.type === 'keys' || (data.name === '@keys')) {
            // Datapoint keys list
            console.log('Received @keys:', data);
            this.emit('datapoint:keys', data);
        } else if (data.type === 'datapoint') {
            // Datapoint update (explicit type)
            console.log('Datapoint update (explicit):', data.name);
            this.emit('datapoint:update', data);
        } else if (data.name && data.data !== undefined) {
            // Datapoint update (implicit - just has name/data fields)
            console.log('Datapoint update (implicit):', data.name);
            // Special case: check if this IS the @keys data
            if (data.name === '@keys') {
                console.log('Found @keys in implicit format:', data);
                this.emit('datapoint:keys', data);
            } else {
                const normalized = {
                    type: 'datapoint',
                    name: data.name,
                    data: data.data,
                    timestamp: data.timestamp,
                    dtype: data.dtype
                };
                this.emit('datapoint:update', normalized);
            }
        } else {
            // Generic message
            console.log('Unhandled message:', data);
        }
    }

    send(data) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(data));
            return true;
        }
        console.warn('WebSocket not connected');
        return false;
    }

    updateStatus(status) {
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.textContent = status === 'connected' ? 'Connected' : 'Disconnected';
            statusElement.className = `status ${status}`;
        }
    }

    close() {
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    }
}

// ============================================
// Global WebSocket instance
// ============================================

const wsManager = new DservWebSocket();

// ============================================
// Resize handle functionality
// ============================================

function initResizeHandles() {
    // Vertical resize (left pane vs datapoint pane)
    initVerticalResize();
    
    // Horizontal resize (terminal vs error log)
    initHorizontalResize();
}

function initVerticalResize() {
    const handle = document.getElementById('vertical-resize-handle');
    const leftPane = document.getElementById('left-pane');
    const datapointPane = document.getElementById('datapoint-pane');
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = datapointPane.offsetWidth;
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const deltaX = startX - e.clientX;
        const newWidth = Math.max(300, Math.min(800, startWidth + deltaX));
        datapointPane.style.width = `${newWidth}px`;
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }
    });
}

function initHorizontalResize() {
    const handle = document.getElementById('horizontal-resize-handle');
    const terminalPane = document.getElementById('terminal-pane');
    const errorLogPane = document.getElementById('error-log-pane');
    let isResizing = false;
    let startY = 0;
    let startHeightTerminal = 0;
    let startHeightError = 0;

    handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeightTerminal = terminalPane.offsetHeight;
        startHeightError = errorLogPane.offsetHeight;
        document.body.style.cursor = 'row-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const deltaY = e.clientY - startY;
        const newTerminalHeight = Math.max(150, startHeightTerminal + deltaY);
        const newErrorHeight = Math.max(100, startHeightError - deltaY);
        
        // Use flex-basis to maintain proportions on window resize
        const total = newTerminalHeight + newErrorHeight;
        terminalPane.style.flex = `${newTerminalHeight / total * 4} 1 0`;
        errorLogPane.style.flex = `${newErrorHeight / total * 4} 1 0`;
    });

    document.addEventListener('mouseup', () => {
        if (isResizing) {
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        }
    });
}

// ============================================
// Initialization
// ============================================

document.addEventListener('DOMContentLoaded', () => {
    // Initialize resize handles
    initResizeHandles();

    // Connect to WebSocket
    wsManager.connect();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    wsManager.close();
});

    </script>
    <script>
// ============================================
// Terminal Module
// ============================================

class Terminal {
    constructor(wsManager) {
        this.ws = wsManager;
        this.container = document.getElementById('terminal');
        this.inputElement = null;
        this.history = JSON.parse(localStorage.getItem('dserv-history') || '[]');
        this.historyIndex = this.history.length;
        
        // Interpreter management
        this.currentInterp = 'dserv';
        this.availableInterps = ['dserv'];
        this.interpSelectorElement = null;
        
        // Tab completion state
        this.completionMatches = [];
        this.completionIndex = -1;
        this.completionOriginal = '';
        this.completionPending = false;
        this.waitingForCompletion = false;

        // Listen for WebSocket events
        this.ws.on('connected', () => this.handleConnected());
        this.ws.on('disconnected', () => this.handleDisconnected());
        this.ws.on('terminal:response', (data) => this.handleResponse(data));
        this.ws.on('datapoint:update', (data) => this.handleDatapointUpdate(data));
        
        // Proxy management (allow the recipient subprocess to forward with this cmd)
        this.currentProxy = null;
        
        // Initialize
        this.init();
    }

    init() {
        this.showInfo('dserv Web Console - Type commands or "help" for assistance');
        this.showInfo('Connecting to WebSocket...');

        // Initialize interpreter selector
        this.interpSelectorElement = document.getElementById('interp-selector');
        if (this.interpSelectorElement) {
            this.interpSelectorElement.addEventListener('change', (e) => {
                this.switchInterpreter(e.target.value);
            });
        }

        // Clear terminal button
        document.getElementById('clear-terminal').addEventListener('click', () => {
            this.clearTerminal();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'l') {
                e.preventDefault();
                this.clearTerminal();
            }
        });
    }

    handleConnected() {
        this.showInfo('Connected to dserv');
        
        // Subscribe to interpreter list
        this.ws.send({
            cmd: 'subscribe',
            match: 'dserv/interps',
            every: 1
        });
        
        // Get current interpreter list
        this.ws.send({
            cmd: 'get',
            name: 'dserv/interps'
        });
        
        this.createInputLine();
    }

    handleDisconnected() {
        this.showInfo('Disconnected from server. Reconnecting...');
        if (this.inputElement) {
            this.inputElement.disabled = true;
        }
    }

    handleDatapointUpdate(data) {
        // Check if this is the dserv/interps datapoint
        if (data.name === 'dserv/interps') {
            const interpsData = data.data !== undefined ? data.data : data.value;
            if (typeof interpsData === 'string') {
                // Parse space-separated list of interpreters
                const interps = interpsData.trim().split(/\s+/).filter(i => i.length > 0);
                this.updateAvailableInterpreters(interps);
            } else if (Array.isArray(interpsData)) {
                this.updateAvailableInterpreters(interpsData);
            }
        }
        
		// Check if this is a proxy response for current interpreter
		const proxyMatch = data.name && data.name.match(/^(.+)\/proxy$/);
		if (proxyMatch && proxyMatch[1] === this.currentInterp) {
			const proxyCmd = data.data !== undefined ? data.data : data.value;
			this.currentProxy = (proxyCmd && proxyCmd.trim()) ? proxyCmd.trim() : null;
			console.log(`Proxy for ${this.currentInterp}: ${this.currentProxy || 'none'}`);
			this.updatePrompt();
		}
    }

    updateAvailableInterpreters(interps) {
	// Always include 'dserv' as the main interpreter
	this.availableInterps = ['dserv', ...interps.filter(i => i !== 'dserv')];
	
	console.log('Available interpreters:', this.availableInterps);
	
	// Notify ConsoleMonitor of interpreter list update
	this.ws.emit('interp-list-updated', this.availableInterps);
	
	// Check if current interpreter still exists
	if (!this.availableInterps.includes(this.currentInterp)) {
            this.currentInterp = 'dserv';
            this.updatePrompt();
	}
	
	// Update selector dropdown
	if (this.interpSelectorElement) {
            const currentValue = this.interpSelectorElement.value;
            this.interpSelectorElement.innerHTML = this.availableInterps
		.map(interp => `<option value="${interp}">${interp}</option>`)
		.join('');
            
            // Set selector to match current interpreter
            this.interpSelectorElement.value = this.currentInterp;
	}
    }
    
    switchInterpreter(interpName) {
        // Validate interpreter exists
        if (!this.availableInterps.includes(interpName)) {
            this.showError(`Unknown interpreter: ${interpName}. Available: ${this.availableInterps.join(', ')}`);
            return false;
        }
        
        this.currentInterp = interpName;
        
		this.currentProxy = null;  // Clear until we get response
		if (interpName !== 'dserv') {
			this.ws.send({
				cmd: 'get',
				name: `${interpName}/proxy`
			});
		}
        
        // Update dropdown if it exists
        if (this.interpSelectorElement) {
            this.interpSelectorElement.value = interpName;
        }
        
        // Update prompt
        this.updatePrompt();
        
        this.showInfo(`Switched to interpreter: ${interpName}`);
        return true;
    }

    updatePrompt() {
        // Update the prompt in existing input line if it exists
        const promptElement = this.container.querySelector('.prompt');
        if (promptElement) {
            promptElement.textContent = `${this.currentInterp}> `;
        }
    }

    createInputLine() {
        // Remove existing input if any
        const existingInput = this.container.querySelector('.input-container');
        if (existingInput) {
            existingInput.remove();
        }

        const container = document.createElement('div');
        container.className = 'input-container';

        const prompt = document.createElement('span');
        prompt.className = 'prompt';
        prompt.textContent = `${this.currentInterp}> `;

        this.inputElement = document.createElement('input');
        this.inputElement.type = 'text';
        this.inputElement.autocomplete = 'off';
        this.inputElement.spellcheck = false;

        container.appendChild(prompt);
        container.appendChild(this.inputElement);
        this.container.appendChild(container);

        this.inputElement.focus();
        this.scrollToBottom();

        // Event handlers
        this.inputElement.addEventListener('keydown', (e) => this.handleKeyDown(e));
        
        // Click anywhere in terminal to focus input (but allow text selection)
        let mouseDownTime = 0;
        let mouseDownPos = { x: 0, y: 0 };
        
        this.container.addEventListener('mousedown', (e) => {
            mouseDownTime = Date.now();
            mouseDownPos = { x: e.clientX, y: e.clientY };
        });
        
        this.container.addEventListener('mouseup', (e) => {
            // Check if this was a click (not a drag for selection)
            const timeDiff = Date.now() - mouseDownTime;
            const distance = Math.sqrt(
                Math.pow(e.clientX - mouseDownPos.x, 2) + 
                Math.pow(e.clientY - mouseDownPos.y, 2)
            );
            
            // If quick click with minimal movement and no text selected
            const selection = window.getSelection();
            if (timeDiff < 300 && distance < 5 && 
                (!selection || selection.toString().length === 0) &&
                e.target !== this.inputElement) {
                this.inputElement.focus();
            }
        });
    }

    handleKeyDown(e) {
        // Handle Tab for completion
        if (e.key === 'Tab') {
            e.preventDefault();
            this.handleTab();
            return;
        }
        
        // Any other key resets completion state
        if (this.completionPending && e.key !== 'Tab') {
            this.completionPending = false;
            this.completionMatches = [];
            this.completionIndex = -1;
        }
        
        switch (e.key) {
            case 'Enter':
                e.preventDefault();
                this.submitCommand();
                break;
            case 'ArrowUp':
                e.preventDefault();
                this.navigateHistory(-1);
                break;
            case 'ArrowDown':
                e.preventDefault();
                this.navigateHistory(1);
                break;
            case 'c':
                if (e.ctrlKey) {
                    e.preventDefault();
                    this.inputElement.value = '';
                }
                break;
        }
    }

    handleTab() {
        if (this.completionPending) {
            // Already have matches, cycle through them
            this.cycleCompletion();
        } else {
            // Start new completion
            this.startCompletion();
        }
    }

    startCompletion() {
        const input = this.inputElement.value;
        
        if (!input.trim()) {
            return; // Don't complete empty input
        }
        
        // Build completion script
        let completeScript;
        
        if (this.currentInterp === 'dserv') {
            completeScript = `complete {${input}}`;
        } else {
            completeScript = `send ${this.currentInterp} {complete {${input}}}`;
        }
        
        // Save original input
        this.completionOriginal = input;
        
        // Mark that we're waiting for completion response
        this.waitingForCompletion = true;
        
        // Send completion request
        this.ws.send({
            cmd: 'eval',
            script: completeScript
        });
    }

    cycleCompletion() {
        if (this.completionMatches.length === 0) return;
        
        // Move to next match
        this.completionIndex = (this.completionIndex + 1) % this.completionMatches.length;
        const match = this.completionMatches[this.completionIndex];
        
        // Update input
        this.inputElement.value = match;
        this.inputElement.setSelectionRange(match.length, match.length);
    }

    parseTclList(str) {
        // Simple parser good enough for most completion results
        if (!str || str.trim() === '') return [];
        
        // For simple space-separated words (99% of cases)
        if (!str.includes('{') && !str.includes('"')) {
            return str.trim().split(/\s+/);
        }
        
        // More robust parser for complex cases
        const items = [];
        let current = '';
        let braceLevel = 0;
        let inQuotes = false;
        let escaped = false;
        
        for (const ch of str) {
            if (escaped) {
                current += ch;
                escaped = false;
                continue;
            }
            
            if (ch === '\\') {
                escaped = true;
                continue;
            }
            
            if (ch === '{' && !inQuotes) {
                if (braceLevel === 0 && current === '') {
                    braceLevel++;
                } else {
                    current += ch;
                    braceLevel++;
                }
            } else if (ch === '}' && !inQuotes) {
                braceLevel--;
                if (braceLevel === 0 && current !== '') {
                    items.push(current);
                    current = '';
                } else {
                    current += ch;
                }
            } else if (ch === '"' && braceLevel === 0) {
                inQuotes = !inQuotes;
                if (!inQuotes && current !== '') {
                    items.push(current);
                    current = '';
                }
            } else if ((ch === ' ' || ch === '\t' || ch === '\n') && braceLevel === 0 && !inQuotes) {
                if (current !== '') {
                    items.push(current);
                    current = '';
                }
            } else {
                current += ch;
            }
        }
        
        if (current !== '') items.push(current);
        return items;
    }

    navigateHistory(direction) {
        if (this.history.length === 0) return;

        this.historyIndex += direction;
        this.historyIndex = Math.max(0, Math.min(this.history.length, this.historyIndex));

        if (this.historyIndex === this.history.length) {
            this.inputElement.value = '';
        } else {
            this.inputElement.value = this.history[this.historyIndex];
        }
    }

    submitCommand() {
        const command = this.inputElement.value.trim();
        
        // Handle empty command - just show prompt and create new line
        if (!command) {
            this.showCommand('');
            
            // Remove input line
            const inputContainer = this.inputElement.parentElement;
            if (inputContainer) {
                inputContainer.remove();
            }
            
            this.createInputLine();
            return;
        }

        // Save to history
        if (command !== this.history[this.history.length - 1]) {
            this.history.push(command);
            if (this.history.length > 100) this.history.shift();
            localStorage.setItem('dserv-history', JSON.stringify(this.history));
        }
        this.historyIndex = this.history.length;

        // Display command with current prompt
        this.showCommand(command);

        // Remove input line
        const inputContainer = this.inputElement.parentElement;
        if (inputContainer) {
            inputContainer.remove();
        }

        // Check for blocked commands
        if (this.isBlockedCommand(command)) {
            this.showWarning('No need to type exit, just close your browser window when done');
            this.createInputLine();
            return;
        }

        // Check for slash commands (interpreter switching or one-off)
        if (command.startsWith('/')) {
            this.handleSlashCommand(command);
            return;
        }

        // Check for local commands
        if (command === 'help') {
            this.showHelp();
            this.createInputLine();
            return;
        }

        if (command === 'clear' || command === 'cls') {
            this.clearTerminal();
            this.createInputLine();
            return;
        }

        // Send command to current interpreter
        this.sendToInterpreter(this.currentInterp, command, true);
    }

    handleSlashCommand(command) {
        // Parse: /interp [command...]
        const parts = command.slice(1).split(/\s+/);
        const targetInterp = parts[0];
        const oneOffCommand = parts.slice(1).join(' ');

        if (!targetInterp) {
            this.showError('Usage: /interp [command] or just /interp to switch');
            this.createInputLine();
            return;
        }

        // Validate interpreter exists
        if (!this.availableInterps.includes(targetInterp)) {
            this.showError(`Unknown interpreter: ${targetInterp}. Available: ${this.availableInterps.join(', ')}`);
            this.createInputLine();
            return;
        }

        if (!oneOffCommand) {
            // Just "/ess" - switch interpreter
            this.switchInterpreter(targetInterp);
            this.createInputLine();
        } else {
            // "/ess pwd" - one-off command, don't switch
            // Build the command to send
            let scriptToSend;
            
            if (this.currentInterp === 'dserv') {
                // From dserv, can directly route to target
                if (targetInterp === 'dserv') {
                    scriptToSend = oneOffCommand;
                } else {
                    scriptToSend = `send ${targetInterp} {${oneOffCommand}}`;
                }
            } else {
                // From subprocess, must route through current subprocess
                if (targetInterp === 'dserv') {
                    // One-off to dserv from subprocess - just send command to dserv directly
                    scriptToSend = oneOffCommand;
                } else if (targetInterp === this.currentInterp) {
                    // Same interpreter - just wrap once
                    scriptToSend = `send ${targetInterp} {${oneOffCommand}}`;
                } else {
                    // Different subprocess - double wrap through current interp
                    scriptToSend = `send ${this.currentInterp} {send ${targetInterp} {${oneOffCommand}}}`;
                }
            }
            
            this.ws.send({
                cmd: 'eval',
                script: scriptToSend
            });
        }
    }

    sendToInterpreter(interpName, command, createNewInput) {
        if (!this.ws.connected) {
            this.showError('Not connected to server');
            if (createNewInput) {
                this.createInputLine();
            }
            return;
        }

        // Wrap command if not targeting main dserv process
        let scriptToSend;
        if (interpName === 'dserv') {
            scriptToSend = command;
	    } else if (this.currentProxy) {
    	    // Relay mode: pass raw command to proxy
        	scriptToSend = `send ${interpName} {${this.currentProxy} {${command}}}`;            
        } else {
            // Escape the command for send - need to handle Tcl braces
            // For safety, we'll wrap in braces
            scriptToSend = `send ${interpName} {${command}}`;
        }

        this.ws.send({
            cmd: 'eval',
            script: scriptToSend
        });
    }

    isBlockedCommand(command) {
        const normalized = command.trim().toLowerCase();
	// once blocked 'exit' but no process that on backend
	return false;
    }

    handleResponse(data) {
        // Check if this is a completion response
        if (this.waitingForCompletion) {
            this.waitingForCompletion = false;
            
            if (data.status === 'ok' && data.result) {
                // Parse Tcl list
                const matches = this.parseTclList(data.result);
                
                if (matches.length === 0) {
                    // No matches - do nothing
                    this.completionPending = false;
                } else if (matches.length === 1) {
                    // Single match - auto-complete immediately
                    this.inputElement.value = matches[0];
                    this.inputElement.setSelectionRange(matches[0].length, matches[0].length);
                    this.completionPending = false;
                } else {
                    // Multiple matches - set up for cycling
                    this.completionMatches = matches;
                    this.completionIndex = 0;
                    this.completionPending = true;
                    
                    // Show first match
                    this.inputElement.value = matches[0];
                    this.inputElement.setSelectionRange(matches[0].length, matches[0].length);
                }
            } else {
                // Error in completion
                this.completionPending = false;
            }
            
            return; // Don't create input line for completion
        }
        
        // Regular command response
        if (data.status === 'error' || (data.result && data.result.startsWith('!TCL_ERROR'))) {
            this.showError(data.result || data.error || 'Unknown error');
        } else if (data.result !== undefined) {
            this.showResult(data.result);
        } else {
            this.showResult(JSON.stringify(data));
        }
        
        // Always create new input line on current interpreter
        this.createInputLine();
    }

    showCommand(text) {
        const line = document.createElement('div');
        line.className = 'output-line command-line';
        line.textContent = `${this.currentInterp}> ${text}`;
        this.container.appendChild(line);
        this.scrollToBottom();
    }

    showResult(text) {
        const line = document.createElement('div');
        line.className = 'output-line result-line';
        line.textContent = text;
        this.container.appendChild(line);
        this.scrollToBottom();
    }

    showError(text) {
        const line = document.createElement('div');
        line.className = 'output-line error-line';
        line.textContent = 'Error: ' + text;
        this.container.appendChild(line);
        this.scrollToBottom();
    }

    showInfo(text) {
        const line = document.createElement('div');
        line.className = 'output-line info-line';
        line.textContent = text;
        this.container.appendChild(line);
        this.scrollToBottom();
    }

    showWarning(text) {
        const line = document.createElement('div');
        line.className = 'output-line warning-line';
        line.textContent = text;
        this.container.appendChild(line);
        this.scrollToBottom();
    }

    showHelp() {
        const helpText = `
dserv Web Console Help
======================

Commands are sent directly to the active interpreter.

Interpreter Switching:
  /interp         - Switch active interpreter to 'interp'
  /interp cmd     - Execute 'cmd' on 'interp' without switching
  
  Examples:
    /ess          - Switch to 'ess' interpreter
    /ess pwd      - Run 'pwd' on 'ess' (stays on current interp)

Local Commands:
  help        - Show this help
  clear/cls   - Clear terminal

Keyboard Shortcuts:
  ‚Üë/‚Üì         - Navigate command history
  Tab         - Auto-complete commands, procs, variables, namespaces
  Ctrl+C      - Clear current line
  Ctrl+L      - Clear terminal
  Enter       - Execute command

Tab Completion:
  Press Tab to complete commands, procedures, variables, and more.
  Context-aware: completes variable names after 'set', namespace
  names after 'namespace eval', etc. Press Tab multiple times to
  cycle through matches.

The terminal connects to dserv via WebSocket and evaluates
Tcl commands in the active interpreter. Use the dropdown or
slash commands to switch between subprocesses.
        `.trim();

        this.showInfo(helpText);
    }

    clearTerminal() {
        this.container.innerHTML = '';
        this.showInfo('Terminal cleared');
        this.createInputLine();
    }

    scrollToBottom() {
        this.container.scrollTop = this.container.scrollHeight;
    }

    focusInput() {
        if (this.inputElement) {
            this.inputElement.focus();
        }
    }
}

// ============================================
// Initialize terminal when DOM is ready
// ============================================

let terminal;

document.addEventListener('DOMContentLoaded', () => {
    terminal = new Terminal(wsManager);

    // Track if user is selecting text
    let isSelecting = false;
    const terminalEl = document.getElementById('terminal');
    
    terminalEl.addEventListener('mousedown', () => {
        isSelecting = false;
    });
    
    terminalEl.addEventListener('mousemove', (e) => {
        if (e.buttons === 1) { // Left mouse button is down
            isSelecting = true;
        }
    });
    
    terminalEl.addEventListener('mouseup', () => {
        // If there's a text selection, don't clear it
        if (window.getSelection().toString().length > 0) {
            isSelecting = true;
        }
    });

    // Focus input when clicking in terminal area (but not if selecting text)
    terminalEl.addEventListener('click', (e) => {
        // Don't focus if user just finished selecting text
        if (isSelecting) {
            isSelecting = false;
            return;
        }
        
        // Only focus if clicking on the container itself or input area
        if (e.target.id === 'terminal' || e.target.classList.contains('input-container')) {
            terminal.focusInput();
        }
    });
    
    // Clean up copied text to remove extra blank lines
    terminalEl.addEventListener('copy', (e) => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const selectedText = selection.toString();
            // Remove multiple consecutive newlines (keep at most one blank line)
            const cleanedText = selectedText.replace(/\n\n+/g, '\n');
            e.clipboardData.setData('text/plain', cleanedText);
            e.preventDefault();
        }
    });
});

    </script>
    <script>
// ============================================
// Datapoint Explorer Module
// ============================================

class DatapointExplorer {
    constructor(wsManager) {
        this.ws = wsManager;
        this.datapoints = new Map(); // name -> { value, timestamp, dtype, history }
        this.subscribedPoints = new Set();
        this.allKeys = [];
        this.selectedDatapoint = null;

        // DOM elements
        this.listElement = document.getElementById('datapoint-list');
        this.detailElement = document.getElementById('datapoint-detail');
        this.searchInput = document.getElementById('search-datapoints');
        this.updateCountElement = document.getElementById('update-count');

        // Listen for WebSocket events
        this.ws.on('connected', () => this.handleConnected());
        this.ws.on('datapoint:update', (data) => this.handleDatapointUpdate(data));
        this.ws.on('datapoint:keys', (data) => this.handleKeysUpdate(data));

        this.init();
    }

    init() {
        // Search functionality
        this.searchInput.addEventListener('input', (e) => {
            this.filterDatapoints(e.target.value);
        });

        this.searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.clearSearch();
            }
        });

        document.getElementById('clear-search').addEventListener('click', () => {
            this.clearSearch();
        });

        // Buttons
        document.getElementById('refresh-keys').addEventListener('click', () => {
            this.refreshKeys();
        });

        document.getElementById('unsubscribe-all').addEventListener('click', () => {
            this.unsubscribeAll();
        });
    }

    handleConnected() {
        this.showPlaceholder('Connected. Loading datapoints...');
        this.refreshKeys();
    }

    refreshKeys() {
        // Subscribe to @keys to get list of all datapoints
        this.ws.send({
            cmd: 'subscribe',
            match: '@keys',
            every: 1
        });
        // Also get current value (like datapoint_explorer does)
        this.ws.send({
            cmd: 'get',
            name: '@keys'
        });
    }

    handleKeysUpdate(data) {
        console.log('handleKeysUpdate called with:', data);
        if (data.name === '@keys' && (data.value || data.data)) {
            try {
                // dserv sends space-separated string (Tcl list): "dserv ess msg ..."
                const keysData = data.data !== undefined ? data.data : data.value;
                console.log('Keys data:', keysData, 'Type:', typeof keysData);
                
                let keys;
                if (typeof keysData === 'string') {
                    // Split on whitespace, like datapoint_explorer does
                    keys = keysData.trim().split(/\s+/).filter(k => k.length > 0);
                } else if (Array.isArray(keysData)) {
                    // Already an array
                    keys = keysData;
                } else {
                    console.error('Unexpected keys format:', keysData);
                    return;
                }
                
                console.log('Parsed keys:', keys);
                this.allKeys = keys;
                this.allKeys.sort();
                console.log('Rendering datapoint list with', this.allKeys.length, 'keys');
                this.renderDatapointList();
            } catch (e) {
                console.error('Failed to parse keys:', e);
            }
        } else {
            console.log('Keys update rejected - missing data. name:', data.name, 'has data/value:', !!(data.data || data.value));
        }
    }

    handleDatapointUpdate(data) {
        const name = data.name;
        if (!name) return;

        // dserv sends 'data' field, not 'value'
        const value = data.data !== undefined ? data.data : data.value;

        // Update datapoint data
        let dpData = this.datapoints.get(name);
        if (!dpData) {
            dpData = {
                value: null,
                timestamp: null,
                dtype: null,
                history: []
            };
            this.datapoints.set(name, dpData);
        }

        dpData.value = value;
        dpData.timestamp = data.timestamp;
        dpData.dtype = data.dtype;
        dpData.history.push({
            time: new Date(),
            value: value,
            timestamp: data.timestamp
        });

        // Keep history limited
        if (dpData.history.length > 100) {
            dpData.history.shift();
        }

        // Update UI if this is the selected datapoint
        if (this.selectedDatapoint === name) {
            this.renderDatapointDetail(name);
        }

        // Update subscribed count
        this.updateSubscribedCount();
    }

    renderDatapointList(filter = '') {
        const filtered = filter 
            ? this.allKeys.filter(key => key.toLowerCase().includes(filter.toLowerCase()))
            : this.allKeys;

        if (filtered.length === 0) {
            this.showPlaceholder(filter ? 'No matching datapoints' : 'No datapoints available');
            return;
        }

        this.listElement.innerHTML = '';

        filtered.forEach(name => {
            const item = document.createElement('div');
            item.className = 'datapoint-item';
            item.id = `dp-${name}`;
            item.textContent = name;

            if (this.subscribedPoints.has(name)) {
                item.classList.add('subscribed');
            }

            if (this.selectedDatapoint === name) {
                item.classList.add('selected');
            }

            // Click to select/subscribe
            item.addEventListener('click', (e) => {
                // Check if clicking on the unsubscribe X
                const rect = item.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                
                if (this.subscribedPoints.has(name) && clickX > rect.width - 35) {
                    // Clicked on X - unsubscribe
                    this.unsubscribe(name);
                } else {
                    // Normal click - select and subscribe if not already
                    this.selectDatapoint(name);
                    if (!this.subscribedPoints.has(name)) {
                        this.subscribe(name);
                    }
                }
            });

            this.listElement.appendChild(item);
        });
    }

    selectDatapoint(name) {
        // Update selection
        this.selectedDatapoint = name;

        // Update UI
        const items = this.listElement.querySelectorAll('.datapoint-item');
        items.forEach(item => item.classList.remove('selected'));

        const selectedItem = document.getElementById(`dp-${name}`);
        if (selectedItem) {
            selectedItem.classList.add('selected');
        }

        // If we don't have data yet, get it (like datapoint_explorer does)
        if (!this.datapoints.has(name)) {
            console.log(`Getting initial value for: ${name}`);
            this.ws.send({
                cmd: 'get',
                name: name
            });
        }

        this.renderDatapointDetail(name);
    }

    renderDatapointDetail(name) {
        const dpData = this.datapoints.get(name);

        if (!dpData || dpData.value === null) {
            this.detailElement.innerHTML = `
                <div class="placeholder">Waiting for data from: ${name}</div>
            `;
            return;
        }

        const history = dpData.history || [];
        const historyHtml = history.slice(-20).reverse().map(update => `
            <div class="update-entry">
                <div class="update-time">${update.time.toLocaleTimeString()}</div>
                <div>${this.formatValue(update.value)}</div>
            </div>
        `).join('');

        this.detailElement.innerHTML = `
            <div class="detail-row">
                <div class="detail-label">Name:</div>
                <div class="detail-value">${name}</div>
            </div>
            <div class="detail-row">
                <div class="detail-label">Datatype:</div>
                <div class="detail-value">${this.getDatatypeName(dpData.dtype)}</div>
            </div>
            <div class="detail-row">
                <div class="detail-label">Timestamp:</div>
                <div class="detail-value">${dpData.timestamp || 'unknown'}</div>
            </div>
            <div class="detail-row">
                <div class="detail-label">Current Value:</div>
                <div class="detail-value">${this.formatValue(dpData.value)}</div>
            </div>
            <div class="detail-row">
                <div class="detail-label">Update History (last 20):</div>
                <div class="update-history">
                    ${historyHtml || '<div class="placeholder">No history</div>'}
                </div>
            </div>
        `;
    }

    formatValue(value) {
        if (value === null || value === undefined) {
            return '<null>';
        }
        if (typeof value === 'object') {
            return JSON.stringify(value, null, 2);
        }
        return String(value);
    }

    getDatatypeName(dtype) {
        const types = {
            0: 'BYTE',
            1: 'STRING',
            2: 'FLOAT',
            3: 'DOUBLE',
            4: 'SHORT',
            5: 'INT',
            6: 'DG',
            7: 'SCRIPT',
            8: 'TRIGGER_SCRIPT',
            9: 'EVENT',
            10: 'NONE',
            11: 'JSON',
            12: 'ARROW',
            13: 'MSGPACK',
            14: 'JPEG',
            15: 'PPM',
            16: 'INT64',
            17: 'UNKNOWN'
        };
        return types[dtype] || `Unknown (${dtype})`;
    }

    subscribe(pattern) {
        if (this.ws.send({
            cmd: 'subscribe',
            match: pattern,
            every: 1
        })) {
            this.subscribedPoints.add(pattern);
            
            const item = document.getElementById(`dp-${pattern}`);
            if (item) {
                item.classList.add('subscribed');
            }

            console.log(`Subscribed to: ${pattern}`);
            this.updateSubscribedCount();
        }
    }

    unsubscribe(pattern) {
        if (this.ws.send({
            cmd: 'unsubscribe',
            match: pattern
        })) {
            this.subscribedPoints.delete(pattern);
            
            const item = document.getElementById(`dp-${pattern}`);
            if (item) {
                item.classList.remove('subscribed');
            }

            console.log(`Unsubscribed from: ${pattern}`);
            this.updateSubscribedCount();
        }
    }

    unsubscribeAll() {
        const toUnsubscribe = Array.from(this.subscribedPoints);
        toUnsubscribe.forEach(pattern => {
            if (pattern !== '@keys') {
                this.unsubscribe(pattern);
            }
        });
    }

    updateSubscribedCount() {
        const count = this.subscribedPoints.size - (this.subscribedPoints.has('@keys') ? 1 : 0);
        this.updateCountElement.textContent = `${count} subscribed`;
    }

    filterDatapoints(filter) {
        this.renderDatapointList(filter);
        
        // Show/hide clear button
        const clearBtn = document.getElementById('clear-search');
        clearBtn.style.display = filter ? 'block' : 'none';
    }

    clearSearch() {
        this.searchInput.value = '';
        this.filterDatapoints('');
    }

    showPlaceholder(message) {
        this.listElement.innerHTML = `<div class="placeholder">${message}</div>`;
    }
}

// ============================================
// Initialize datapoint explorer when DOM is ready
// ============================================

let datapointExplorer;

document.addEventListener('DOMContentLoaded', () => {
    datapointExplorer = new DatapointExplorer(wsManager);
});

    </script>
    <script>
// ============================================
// Error Monitor Module
// ============================================

class ErrorMonitor {
    constructor(wsManager) {
        this.ws = wsManager;
        this.errors = []; // Array of error objects
        this.maxErrors = 100; // Keep last 100 errors
        this.errorPattern = 'error/*'; // Pattern to match all error datapoints
        this.isSubscribed = false;

        // DOM elements
        this.logListElement = document.getElementById('error-log-list');
        this.logCountElement = document.getElementById('error-log-count');
        this.badgeElement = document.getElementById('error-badge');
        this.clearButton = document.getElementById('clear-error-log');
        this.tabBadgeElement = document.getElementById('errors-badge');

        // Listen for WebSocket events
        this.ws.on('connected', () => this.handleConnected());
        this.ws.on('datapoint:update', (data) => this.handleDatapointUpdate(data));

        this.init();
    }

    init() {
        this.attachEventListeners();
    }

    attachEventListeners() {
        // Badge click - scroll to error log
        if (this.badgeElement) {
            this.badgeElement.addEventListener('click', () => this.scrollToErrorLog());
        }

        // ESC key to clear selection (optional)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Could add behavior here if needed
            }
        });
    }

    scrollToErrorLog() {
        const errorLogPane = document.getElementById('error-log-pane');
        if (errorLogPane) {
            errorLogPane.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            // Briefly highlight the error log
            errorLogPane.style.borderTop = '2px solid #d32f2f';
            setTimeout(() => {
                errorLogPane.style.borderTop = '1px solid #3e3e42';
            }, 1000);
        }
    }

    handleConnected() {
        // Subscribe to all error datapoints
        this.subscribeToErrors();
    }

    subscribeToErrors() {
        // Subscribe to error pattern
        this.ws.send({
            cmd: 'subscribe',
            match: 'error/*',
            every: 1
        });
        this.isSubscribed = true;
        console.log('Subscribed to error/* for monitoring');
    }

    handleDatapointUpdate(data) {
        // Check if this is an error datapoint
        if (!data.name || !data.name.startsWith('error/')) {
            return;
        }

        const value = data.data !== undefined ? data.data : data.value;
        
        // Skip if empty/null
        if (!value) {
            return;
        }

        // Parse error data
        let errorData;
        try {
            if (typeof value === 'string') {
                // Try to parse as JSON
                try {
                    errorData = JSON.parse(value);
                } catch {
                    // If not JSON, treat as plain errorInfo string
                    errorData = {
                        interpreter: data.name.replace('error/', ''),
                        errorInfo: value,
                        timestamp: data.timestamp || Date.now()
                    };
                }
            } else if (typeof value === 'object') {
                errorData = value;
            } else {
                return; // Unknown format
            }
        } catch (e) {
            console.error('Failed to parse error data:', e);
            return;
        }

        // Add metadata
        errorData.dpName = data.name;
        errorData.receivedAt = new Date();
        errorData.id = Date.now() + Math.random();

        // Check for duplicates - don't add if last error is identical
        if (this.errors.length > 0) {
            const lastError = this.errors[this.errors.length - 1];
            if (lastError.interpreter === errorData.interpreter &&
                lastError.errorInfo === errorData.errorInfo &&
                lastError.errorCode === errorData.errorCode) {
                console.log('Duplicate error ignored:', errorData.interpreter);
                return; // Skip duplicate
            }
        }

        // Add to errors list
        this.errors.push(errorData);

        // Limit errors
        if (this.errors.length > this.maxErrors) {
            this.errors.shift();
        }

        // Update UI
        this.renderErrorLog();
        this.updateBadge();
        // No toast notification - error log is always visible

        console.log('Error logged:', errorData);
    }

    renderErrorLog() {
        if (this.errors.length === 0) {
            this.logListElement.innerHTML = '<div class="placeholder">No errors logged</div>';
            return;
        }

        // Render errors (newest first)
        const errorsHtml = this.errors.slice().reverse().map(error => {
            const firstLine = this.getFirstLine(error.errorInfo);
            const fullError = this.formatErrorInfo(error.errorInfo);
            const interpName = error.interpreter || error.dpName.replace('error/', '') || 'unknown';
            
            return `
                <div class="error-log-item collapsed" data-error-id="${error.id}">
                    <div class="error-log-item-header">
                        <span class="error-log-interp">${interpName}</span>
                        <span class="error-log-preview">${this.escapeHtml(firstLine)}</span>
                        <span class="error-log-time">${this.formatTime(error.receivedAt)}</span>
                    </div>
                    <div class="error-log-details">
                        <pre class="error-log-info">${fullError}</pre>
                        ${error.errorCode ? `<div class="error-log-code">Code: <code>${this.escapeHtml(error.errorCode)}</code></div>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        this.logListElement.innerHTML = errorsHtml;

        // Add click handlers to toggle expand/collapse
        this.logListElement.querySelectorAll('.error-log-item').forEach(item => {
            item.addEventListener('click', () => {
                item.classList.toggle('collapsed');
            });
        });

        // Auto-scroll to top (newest error)
        this.logListElement.scrollTop = 0;
    }

    getFirstLine(errorInfo) {
        if (!errorInfo) return 'No error information';
        const str = String(errorInfo);
        const firstLine = str.split('\n')[0];
        // Limit length
        return firstLine.length > 80 ? firstLine.substring(0, 80) + '...' : firstLine;
    }

    formatErrorInfo(errorInfo) {
        if (!errorInfo) return 'No error information';
        
        // Escape HTML
        const escaped = this.escapeHtml(String(errorInfo));
        
        // Limit length for display
        if (escaped.length > 300) {
            return escaped.substring(0, 300) + '\n... (truncated)';
        }
        
        return escaped;
    }

    formatTime(date) {
        const now = new Date();
        const diff = now - date;
        
        if (diff < 60000) { // Less than 1 minute
            return 'just now';
        } else if (diff < 3600000) { // Less than 1 hour
            const mins = Math.floor(diff / 60000);
            return `${mins}m ago`;
        } else if (diff < 86400000) { // Less than 1 day
            return date.toLocaleTimeString();
        } else {
            return date.toLocaleString();
        }
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    updateBadge() {
        // Update count
        this.logCountElement.textContent = `${this.errors.length} error${this.errors.length === 1 ? '' : 's'}`;
        
        // Show/hide badge
        if (this.errors.length === 0) {
            this.badgeElement.classList.add('hidden');
        } else {
            this.badgeElement.classList.remove('hidden');
            this.badgeElement.querySelector('.error-count').textContent = this.errors.length;
        }
        
        // Update tab badge
        if (this.tabBadgeElement) {
            const errorTab = document.querySelector('.pane-tab[data-tab="errors"]');
            if (this.errors.length === 0 || (errorTab && errorTab.classList.contains('active'))) {
                this.tabBadgeElement.classList.add('hidden');
            } else {
                this.tabBadgeElement.classList.remove('hidden');
                this.tabBadgeElement.textContent = this.errors.length;
            }
        }
    }

    clearErrors() {
        if (this.errors.length === 0) return;
        
        this.errors = [];
        this.renderErrorLog();
        this.updateBadge();
    }
}

// ============================================
// Console Monitor Module
// ============================================

class ConsoleMonitor {
    constructor(wsManager) {
        this.ws = wsManager;
        this.consoleBlocks = []; // Array of console blocks (one per interpreter session)
        this.currentBlock = null; // Currently active block being accumulated
        this.maxBlocks = 100; // Keep last 100 blocks
        this.stdoutSubscriptions = new Set(); // Track subscribed interpreters
        
        // Color palette for interpreters
        this.interpColors = {};
        this.colorPalette = [
            '#4ec9b0', // teal
            '#ce9178', // orange
            '#c586c0', // purple
            '#dcdcaa', // yellow
            '#569cd6', // blue
            '#4fc1ff', // cyan
            '#b5cea8', // green
            '#d16969', // red
            '#9cdcfe', // light blue
            '#f48771'  // salmon
        ];
        
        // DOM elements
        this.consoleListElement = document.getElementById('console-log-list');
        this.logCountElement = document.getElementById('error-log-count'); // Shared with errors
        this.tabBadgeElement = document.getElementById('console-badge');
        
        // Listen for WebSocket events
        this.ws.on('connected', () => this.handleConnected());
        this.ws.on('datapoint:update', (data) => this.handleDatapointUpdate(data));
        
        // Listen for interpreter list updates
        this.ws.on('interp-list-updated', (interps) => this.updateStdoutSubscriptions(interps));
    }
    
    getInterpColor(interpreter) {
        // Return existing color if we've seen this interpreter
        if (this.interpColors[interpreter]) {
            return this.interpColors[interpreter];
        }
        
        // Assign a new color from palette
        const usedColors = Object.values(this.interpColors);
        const availableColors = this.colorPalette.filter(c => !usedColors.includes(c));
        
        // If we've used all colors, start reusing them
        const color = availableColors.length > 0 
            ? availableColors[0] 
            : this.colorPalette[Object.keys(this.interpColors).length % this.colorPalette.length];
        
        this.interpColors[interpreter] = color;
        return color;
    }
    
    handleConnected() {
        // Will subscribe once we get the interpreter list
        console.log('ConsoleMonitor: WebSocket connected, waiting for interpreter list');
    }
    
    updateStdoutSubscriptions(interps) {
        if (!interps || !Array.isArray(interps)) return;
        
        // Get list of non-dserv interpreters
        const activeInterps = interps.filter(name => name !== 'dserv');
        
        // Unsubscribe from interpreters that are no longer active
        for (const interp of this.stdoutSubscriptions) {
            if (!activeInterps.includes(interp)) {
                const dpName = `${interp}/stdout`;
                this.ws.send({
                    cmd: 'unsubscribe',
                    match: dpName
                });
                this.stdoutSubscriptions.delete(interp);
                console.log(`ConsoleMonitor: Unsubscribed from ${dpName}`);
            }
        }
        
        // Subscribe to new interpreters
        for (const interp of activeInterps) {
            if (!this.stdoutSubscriptions.has(interp)) {
                const dpName = `${interp}/stdout`;
                this.ws.send({
                    cmd: 'subscribe',
                    match: dpName,
                    every: 1
                });
                this.stdoutSubscriptions.add(interp);
                console.log(`ConsoleMonitor: Subscribed to ${dpName}`);
            }
        }
    }
    
    handleDatapointUpdate(data) {
        // Check if this is a stdout message
        if (data.name && data.name.endsWith('/stdout')) {
            const interpName = data.name.replace('/stdout', '');
            const value = data.data !== undefined ? data.data : data.value;
            this.addConsoleMessage(interpName, value);
        }
    }
    
    addConsoleMessage(interpreter, message) {
        if (!message) return;
        
        // Check if we should append to current block or start a new one
        if (this.currentBlock && this.currentBlock.interpreter === interpreter) {
            // Append to current block
            this.currentBlock.lines.push(String(message));
            this.currentBlock.lastUpdated = new Date();
        } else {
            // Finalize current block if exists
            if (this.currentBlock) {
                this.consoleBlocks.push(this.currentBlock);
                this.currentBlock = null;
                
                // Limit blocks
                if (this.consoleBlocks.length > this.maxBlocks) {
                    this.consoleBlocks.shift();
                }
            }
            
            // Start new block
            this.currentBlock = {
                id: Date.now() + Math.random(),
                interpreter: interpreter,
                lines: [String(message)],
                startedAt: new Date(),
                lastUpdated: new Date()
            };
        }
        
        // Update UI
        this.renderConsoleLog();
        
        console.log(`Console [${interpreter}]:`, message);
    }
    
    renderConsoleLog() {
        // Get all blocks including current active one
        const allBlocks = [...this.consoleBlocks];
        if (this.currentBlock) {
            allBlocks.push(this.currentBlock);
        }
        
        if (allBlocks.length === 0) {
            this.consoleListElement.innerHTML = '<div class="placeholder">No console output</div>';
            this.updateBadge();
            return;
        }
        
        // Render blocks (newest first)
        const blocksHtml = allBlocks.slice().reverse().map(block => {
            const messageText = block.lines.join('');  // Simple join - puts includes newline
            const isActive = block === this.currentBlock;
            const color = this.getInterpColor(block.interpreter);
            const borderWidth = isActive ? '5px' : '4px';
            
            return `
                <div class="console-block ${isActive ? 'active' : ''}" style="border-left: ${borderWidth} solid ${color};">
                    <div class="console-block-header">
                        <span class="console-log-time">${this.formatTime(block.startedAt)}</span>
                        <span class="console-log-interp" style="color: ${color};">[${block.interpreter}]</span>
                        ${isActive ? `<span class="console-active-indicator" style="color: ${color};">‚óè</span>` : ''}
                    </div>
                    <pre class="console-block-content">${this.escapeHtml(messageText)}</pre>
                </div>
            `;
        }).join('');
        
        this.consoleListElement.innerHTML = blocksHtml;
        
        // Auto-scroll to top (newest block)
        this.consoleListElement.scrollTop = 0;
        
        // Update badge
        this.updateBadge();
    }
    
    updateBadge() {
        if (this.tabBadgeElement) {
            const totalBlocks = this.consoleBlocks.length + (this.currentBlock ? 1 : 0);
            const consoleTab = document.querySelector('.pane-tab[data-tab="console"]');
            if (totalBlocks === 0 || (consoleTab && consoleTab.classList.contains('active'))) {
                this.tabBadgeElement.classList.add('hidden');
            } else {
                this.tabBadgeElement.classList.remove('hidden');
                this.tabBadgeElement.textContent = totalBlocks;
            }
        }
    }
    
    formatTime(date) {
        const now = new Date();
        const diff = now - date;
        
        if (diff < 60000) { // Less than 1 minute
            const seconds = Math.floor(diff / 1000);
            return seconds === 0 ? 'now' : `${seconds}s`;
        } else if (diff < 3600000) { // Less than 1 hour
            const minutes = Math.floor(diff / 60000);
            return `${minutes}m`;
        } else if (diff < 86400000) { // Less than 1 day
            const hours = Math.floor(diff / 3600000);
            return `${hours}h`;
        } else {
            // Format as HH:MM
            return date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false 
            });
        }
    }
    
    escapeHtml(unsafe) {
        if (unsafe === null || unsafe === undefined) return '';
        return String(unsafe)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
    
    clearConsole() {
        if (this.consoleBlocks.length === 0 && !this.currentBlock) return;
        
        this.consoleBlocks = [];
        this.currentBlock = null;
        this.renderConsoleLog();
    }
}

// ============================================
// Tab Switching for Error/Console Panel
// ============================================

function initializePaneTabs() {
    const tabs = document.querySelectorAll('.pane-tab');
    const errorList = document.getElementById('error-log-list');
    const consoleList = document.getElementById('console-log-list');
    const clearButton = document.getElementById('clear-error-log');
    const countElement = document.getElementById('error-log-count');
    
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const targetTab = tab.dataset.tab;
            
            // Update active tab
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Show appropriate content
            if (targetTab === 'errors') {
                errorList.classList.add('active');
                consoleList.classList.remove('active');
                countElement.textContent = `${errorMonitor.errors.length} error${errorMonitor.errors.length === 1 ? '' : 's'}`;
                // Hide error badge when viewing errors
                errorMonitor.updateBadge();
            } else if (targetTab === 'console') {
                errorList.classList.remove('active');
                consoleList.classList.add('active');
                const totalBlocks = consoleMonitor.consoleBlocks.length + (consoleMonitor.currentBlock ? 1 : 0);
                countElement.textContent = `${totalBlocks} block${totalBlocks === 1 ? '' : 's'}`;
                // Hide console badge when viewing console
                consoleMonitor.updateBadge();
            }
        });
    });
    
    // Update clear button to work with current tab
    clearButton.addEventListener('click', () => {
        const activeTab = document.querySelector('.pane-tab.active');
        if (activeTab) {
            const targetTab = activeTab.dataset.tab;
            if (targetTab === 'errors') {
                errorMonitor.clearErrors();
            } else if (targetTab === 'console') {
                consoleMonitor.clearConsole();
            }
        }
    });
}

// ============================================
// Sandbox Editor - Multi-line code editor
// ============================================

class SandboxEditor {
    constructor(ws, terminal) {
        this.ws = ws;
        this.terminal = terminal;
        
        // DOM elements
        this.pane = document.getElementById('sandbox-editor-pane');
        this.textarea = document.getElementById('sandbox-textarea');
        this.toggleBtn = document.getElementById('sandbox-editor-toggle');
        this.formatBtn = document.getElementById('sandbox-format-btn');
        this.lintBtn = document.getElementById('sandbox-lint-btn');
        this.clearBtn = document.getElementById('sandbox-clear-btn');
        this.executeBtn = document.getElementById('sandbox-execute-btn');
        this.lineInfo = document.getElementById('sandbox-line-info');
        this.lintStatus = document.getElementById('sandbox-lint-status');
        this.interpTarget = document.getElementById('sandbox-interp-target');
        this.resizeHandle = document.getElementById('editor-resize-handle');
        
        // State
        this.isCollapsed = false;
        this.lintTimeout = null;
        this.lintPopup = null;
        this.lastLintResult = null;
        
        // Load saved state
        this.loadState();
        
        // Initialize
        this.init();
    }
    
    init() {
        // Toggle collapse/expand
        this.toggleBtn.addEventListener('click', (e) => {
            // Don't toggle if clicking on controls
            if (e.target.closest('.sandbox-editor-controls')) return;
            this.toggleCollapse();
        });
        
        // Button handlers
        this.formatBtn.addEventListener('click', () => this.formatCode());
        this.lintBtn.addEventListener('click', () => this.showLintResults());
        this.clearBtn.addEventListener('click', () => this.clearEditor());
        this.executeBtn.addEventListener('click', () => this.executeCode());
        
        // Textarea events
        this.textarea.addEventListener('input', () => this.handleInput());
        this.textarea.addEventListener('keydown', (e) => this.handleKeyDown(e));
        this.textarea.addEventListener('click', () => this.updateCursorPosition());
        this.textarea.addEventListener('keyup', () => this.updateCursorPosition());
        
        // Tab handling in textarea
        this.textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault();
                this.insertTab();
            }
        });
        
        // Resize handle
        this.initResize();
        
        // Update interpreter target when terminal changes
        this.updateInterpTarget();
        
        // Listen for interpreter changes
        const interpSelector = document.getElementById('interp-selector');
        if (interpSelector) {
            interpSelector.addEventListener('change', () => this.updateInterpTarget());
        }
        
        // Close lint popup on outside click
        document.addEventListener('click', (e) => {
            if (this.lintPopup && !this.lintPopup.contains(e.target) && e.target !== this.lintBtn) {
                this.closeLintPopup();
            }
        });
    }
    
    loadState() {
        try {
            const saved = localStorage.getItem('sandbox-editor-state');
            if (saved) {
                const state = JSON.parse(saved);
                if (state.content) {
                    this.textarea.value = state.content;
                }
                if (state.collapsed) {
                    this.isCollapsed = true;
                    this.pane.classList.add('collapsed');
                }
                if (state.height) {
                    this.pane.querySelector('.sandbox-editor-content').style.height = state.height + 'px';
                }
            }
        } catch (e) {
            console.error('Failed to load sandbox state:', e);
        }
    }
    
    saveState() {
        try {
            const content = this.textarea.value;
            const contentEl = this.pane.querySelector('.sandbox-editor-content');
            localStorage.setItem('sandbox-editor-state', JSON.stringify({
                content: content,
                collapsed: this.isCollapsed,
                height: contentEl ? contentEl.offsetHeight : null
            }));
        } catch (e) {
            console.error('Failed to save sandbox state:', e);
        }
    }
    
    toggleCollapse() {
        this.isCollapsed = !this.isCollapsed;
        this.pane.classList.toggle('collapsed', this.isCollapsed);
        this.saveState();
    }
    
    handleInput() {
        // Save content on change
        this.saveState();
        
        // Debounced lint
        if (this.lintTimeout) {
            clearTimeout(this.lintTimeout);
        }
        this.lintTimeout = setTimeout(() => this.lintCode(), 500);
    }
    
    handleKeyDown(e) {
        // Shift+Enter to execute
        if (e.key === 'Enter' && e.shiftKey) {
            e.preventDefault();
            this.executeCode();
            return;
        }
        
        // Mod+Shift+F to format
        if (e.key === 'f' && e.shiftKey && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            this.formatCode();
            return;
        }
        
        // Escape to close lint popup
        if (e.key === 'Escape' && this.lintPopup) {
            this.closeLintPopup();
        }
    }
    
    insertTab() {
        const start = this.textarea.selectionStart;
        const end = this.textarea.selectionEnd;
        const value = this.textarea.value;
        
        // Insert 4 spaces
        this.textarea.value = value.substring(0, start) + '    ' + value.substring(end);
        this.textarea.selectionStart = this.textarea.selectionEnd = start + 4;
        
        this.handleInput();
    }
    
    updateCursorPosition() {
        const value = this.textarea.value;
        const pos = this.textarea.selectionStart;
        
        // Count lines and column
        const textBefore = value.substring(0, pos);
        const lines = textBefore.split('\n');
        const line = lines.length;
        const col = lines[lines.length - 1].length + 1;
        
        this.lineInfo.textContent = `Ln ${line}, Col ${col}`;
    }
    
    updateInterpTarget() {
        const interpSelector = document.getElementById('interp-selector');
        const interp = interpSelector ? interpSelector.value : 'dserv';
        this.interpTarget.textContent = `‚Üí ${interp}`;
    }
    
    formatCode() {
        const code = this.textarea.value;
        if (!code.trim()) return;
        
        // Check if TclFormatter is available
        if (typeof TclFormatter === 'undefined') {
            console.warn('TclFormatter not loaded');
            return;
        }
        
        try {
            const formatted = TclFormatter.formatTclCode(code, 4);
            this.textarea.value = formatted;
            this.saveState();
            this.lintCode();
        } catch (e) {
            console.error('Format error:', e);
        }
    }
    
    lintCode() {
        const code = this.textarea.value;
        
        if (!code.trim()) {
            this.lintStatus.textContent = '‚úì Ready';
            this.lintStatus.className = 'sandbox-status-item success';
            this.lastLintResult = null;
            return;
        }
        
        // Check if TclLinter is available
        if (typeof TclLinter === 'undefined') {
            this.lintStatus.textContent = '? Linter not loaded';
            this.lintStatus.className = 'sandbox-status-item';
            return;
        }
        
        try {
            const linter = new TclLinter();
            const result = linter.lint(code);
            this.lastLintResult = result;
            
            const errorCount = result.errors.length;
            const warningCount = result.warnings.length;
            
            if (errorCount === 0 && warningCount === 0) {
                this.lintStatus.textContent = '‚úì No issues';
                this.lintStatus.className = 'sandbox-status-item success';
            } else if (errorCount > 0) {
                this.lintStatus.textContent = `‚úó ${errorCount} error${errorCount > 1 ? 's' : ''}${warningCount > 0 ? `, ${warningCount} warning${warningCount > 1 ? 's' : ''}` : ''}`;
                this.lintStatus.className = 'sandbox-status-item error';
            } else {
                this.lintStatus.textContent = `‚ö† ${warningCount} warning${warningCount > 1 ? 's' : ''}`;
                this.lintStatus.className = 'sandbox-status-item warning';
            }
        } catch (e) {
            console.error('Lint error:', e);
            this.lintStatus.textContent = '? Lint failed';
            this.lintStatus.className = 'sandbox-status-item';
        }
    }
    
    showLintResults() {
        // Force a lint first
        this.lintCode();
        
        if (!this.lastLintResult) {
            return;
        }
        
        const { errors, warnings } = this.lastLintResult;
        const allIssues = [...errors, ...warnings];
        
        if (allIssues.length === 0) {
            // No issues, show brief message
            this.lintStatus.textContent = '‚úì No issues found';
            this.lintStatus.className = 'sandbox-status-item success';
            return;
        }
        
        // Close existing popup
        this.closeLintPopup();
        
        // Create popup
        this.lintPopup = document.createElement('div');
        this.lintPopup.className = 'sandbox-lint-popup';
        
        allIssues.forEach(issue => {
            const item = document.createElement('div');
            item.className = `sandbox-lint-item ${issue.severity}`;
            item.innerHTML = `
                <div class="sandbox-lint-location">Line ${issue.line}, Col ${issue.column}</div>
                <div class="sandbox-lint-message">${this.escapeHtml(issue.message)}</div>
            `;
            
            // Click to jump to line
            item.addEventListener('click', () => {
                this.jumpToLine(issue.line, issue.column);
                this.closeLintPopup();
            });
            
            this.lintPopup.appendChild(item);
        });
        
        // Position popup below the lint button
        const btnRect = this.lintBtn.getBoundingClientRect();
        this.lintPopup.style.position = 'fixed';
        this.lintPopup.style.left = btnRect.left + 'px';
        this.lintPopup.style.top = (btnRect.bottom + 4) + 'px';
        
        document.body.appendChild(this.lintPopup);
    }
    
    closeLintPopup() {
        if (this.lintPopup) {
            this.lintPopup.remove();
            this.lintPopup = null;
        }
    }
    
    jumpToLine(line, col) {
        const lines = this.textarea.value.split('\n');
        let pos = 0;
        
        for (let i = 0; i < line - 1 && i < lines.length; i++) {
            pos += lines[i].length + 1; // +1 for newline
        }
        pos += Math.min(col - 1, lines[line - 1]?.length || 0);
        
        this.textarea.focus();
        this.textarea.setSelectionRange(pos, pos);
        this.updateCursorPosition();
    }
    
    clearEditor() {
        this.textarea.value = '';
        this.saveState();
        this.lintCode();
        this.textarea.focus();
    }
    
    executeCode() {
        const code = this.textarea.value.trim();
        if (!code) return;
        
        // Get target interpreter
        const interpSelector = document.getElementById('interp-selector');
        const targetInterp = interpSelector ? interpSelector.value : 'dserv';
        
        // Send to terminal for execution
        if (this.terminal) {
            this.terminal.sendToInterpreter(targetInterp, code, true);
        } else {
            // Fallback: send directly via WebSocket
            let scriptToSend;
            if (targetInterp === 'dserv') {
                scriptToSend = code;
            } else {
                scriptToSend = `send ${targetInterp} {${code}}`;
            }
            
            this.ws.send({
                cmd: 'eval',
                script: scriptToSend
            });
        }
    }
    
    initResize() {
        let isResizing = false;
        let startY = 0;
        let startEditorHeight = 0;
        const contentEl = this.pane.querySelector('.sandbox-editor-content');
        const terminalPane = document.getElementById('terminal-pane');
        const errorLogPane = document.getElementById('error-log-pane');
        
        // Set initial height if not set
        if (!contentEl.style.height) {
            contentEl.style.height = contentEl.offsetHeight + 'px';
        }
        
        this.resizeHandle.addEventListener('mousedown', (e) => {
            if (this.isCollapsed) return;
            isResizing = true;
            startY = e.clientY;
            startEditorHeight = contentEl.offsetHeight;
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const deltaY = e.clientY - startY;
            const newEditorHeight = Math.max(80, startEditorHeight + deltaY);
            
            contentEl.style.height = newEditorHeight + 'px';
            // Let terminal and error panes flex naturally to fill remaining space
        });
        
        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                this.saveState();
            }
        });
    }
    
    escapeHtml(str) {
        if (!str) return '';
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    }
}

// ============================================
// Initialize all components when DOM is ready
// ============================================

let errorMonitor;
let consoleMonitor;
let sandboxEditor;

document.addEventListener('DOMContentLoaded', () => {
    errorMonitor = new ErrorMonitor(wsManager);
    consoleMonitor = new ConsoleMonitor(wsManager);
    initializePaneTabs();
    
    // Initialize sandbox editor after terminal is ready
    // Terminal is created in wsManager.on('connected') via Terminal class
    setTimeout(() => {
        sandboxEditor = new SandboxEditor(wsManager, terminal);
    }, 100);
});

    </script>
</body>
</html>