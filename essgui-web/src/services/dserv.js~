import { reactive } from 'vue'
import { message } from 'ant-design-vue'

class DservWebSocket {
  constructor() {
    this.ws = null
    this.reconnectAttempts = 0
    this.maxReconnectAttempts = 5
    this.reconnectInterval = 2000
    this.requestCallbacks = new Map()
    
    // Reactive state matching your FLTK interface
    this.state = reactive({
      connected: false,
      systems: [],
      protocols: [],
      variants: [],
      branches: [],
      currentSystem: '',
      currentProtocol: '',
      currentVariant: '',
      currentBranch: '',
      status: 'disconnected', // 'Stopped', 'Running', 'loading'
      obsCount: '',
      obsId: 0,
      obsTotal: 0,
      blockPctComplete: 0,
      blockPctCorrect: 0,
      subject: '',
      systemName: '',
      systemOS: '',
      inObs: false
    })
    
    this.connect()
  }
  
  connect() {
    // Auto-detect WebSocket URL (for embedded deployment)
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
    const host = window.location.host || 'localhost:2565'
    const wsUrl = `${protocol}//${host}/ws`
    
    console.log(`Connecting to ${wsUrl}`)
    this.ws = new WebSocket(wsUrl)
    
    this.ws.onopen = () => {
      console.log('Connected to dserv')
      this.state.connected = true
      this.reconnectAttempts = 0
      
      // Subscribe to all ESS updates (matching your essgui subscriptions)
      this.subscribe('ess/*')
      this.subscribe('system/*')
      this.subscribe('print')
      
      message.success('Connected to dserv')
    }
    
    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data)
        this.handleMessage(data)
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error)
      }
    }
    
    this.ws.onclose = () => {
      this.state.connected = false
      this.attemptReconnect()
    }
    
    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error)
    }
  }
  
  subscribe(pattern, every = 1) {
    this.send({
      cmd: 'subscribe',
      match: pattern,
      every: every
    })
  }
  
  send(messageObj) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(messageObj))
    }
  }
  
  // Execute ESS commands (equivalent to esscmd() in your FLTK app)
  essCommand(command) {
    return new Promise((resolve, reject) => {
      if (!this.state.connected) {
        reject(new Error('Not connected to dserv'))
        return
      }
      
      const requestId = Date.now().toString() + Math.random().toString(36).substr(2, 9)
      
      // Set up timeout
      const timeout = setTimeout(() => {
        this.requestCallbacks.delete(requestId)
        reject(new Error(`Command timeout: ${command}`))
      }, 10000)
      
      // Store callback
      this.requestCallbacks.set(requestId, { resolve, reject, timeout })
      
      this.send({
        cmd: 'eval',
        script: command,
        requestId: requestId
      })
    })
  }
  
  handleMessage(data) {
    // Handle command responses
    if (data.requestId && this.requestCallbacks.has(data.requestId)) {
      const { resolve, reject, timeout } = this.requestCallbacks.get(data.requestId)
      clearTimeout(timeout)
      this.requestCallbacks.delete(data.requestId)
      
      if (data.status === 'ok') {
        resolve(data.result)
      } else {
        reject(new Error(data.error || 'Command failed'))
      }
      return
    }
    
    // Handle datapoint updates (equivalent to process_dpoint_cb in essgui.cxx)
    if (data.type === 'datapoint') {
      this.handleDatapoint(data)
    }
  }
  
  handleDatapoint(data) {
    const { name, data: value } = data
    
    switch (name) {
      case 'ess/systems':
        this.state.systems = this.parseList(value)
        break
      case 'ess/protocols':
        this.state.protocols = this.parseList(value)
        break
      case 'ess/variants':
        this.state.variants = this.parseList(value)
        break
      case 'ess/git/branches':
        this.state.branches = this.parseList(value)
        break
      case 'ess/system':
        this.state.currentSystem = value
        break
      case 'ess/protocol':
        this.state.currentProtocol = value
        break
      case 'ess/variant':
        this.state.currentVariant = value
        break
      case 'ess/git/branch':
        this.state.currentBranch = value
        break
      case 'ess/status':
      case 'ess/state':
        this.state.status = value
        break
      case 'ess/obs_id':
        this.state.obsId = parseInt(value)
        this.updateObsCount()
        break
      case 'ess/obs_total':
        this.state.obsTotal = parseInt(value)
        this.updateObsCount()
        break
      case 'ess/in_obs':
        this.state.inObs = value === '1'
        break
      case 'ess/block_pct_complete':
        this.state.blockPctComplete = Math.round(parseFloat(value) * 100)
        break
      case 'ess/block_pct_correct':
        this.state.blockPctCorrect = Math.round(parseFloat(value) * 100)
        break
      case 'ess/subject':
        this.state.subject = value
        break
      case 'system/hostname':
        this.state.systemName = value
        break
      case 'system/os':
        this.state.systemOS = value
        break
      case 'print':
        console.log('ESS:', value)
        break
      default:
        console.log(`Unhandled datapoint: ${name} = ${value}`)
    }
  }
  
  parseList(tcl_list) {
    if (!tcl_list || tcl_list === '') return []
    return tcl_list.split(' ').filter(item => item.length > 0)
  }
  
  updateObsCount() {
    if (this.state.obsTotal > 0) {
      this.state.obsCount = `${this.state.obsId + 1}/${this.state.obsTotal}`
    } else {
      this.state.obsCount = ''
    }
  }
  
  attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++
      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`)
      setTimeout(() => this.connect(), this.reconnectInterval)
    } else {
      message.error('Failed to reconnect to dserv')
    }
  }
  
  // ESS command methods (matching your FLTK callbacks)
  async setSystem(system) {
    message.loading({ content: `Loading system: ${system}`, key: 'system-load' })
    try {
      await this.essCommand(`ess::load_system ${system}`)
      message.success({ content: `System loaded: ${system}`, key: 'system-load' })
    } catch (error) {
      message.error({ content: `Failed to load system: ${error.message}`, key: 'system-load' })
      throw error
    }
  }
  
  async setProtocol(protocol) {
    message.loading({ content: `Loading protocol: ${protocol}`, key: 'protocol-load' })
    try {
      await this.essCommand(`ess::load_system ${this.state.currentSystem} ${protocol}`)
      message.success({ content: `Protocol loaded: ${protocol}`, key: 'protocol-load' })
    } catch (error) {
      message.error({ content: `Failed to load protocol: ${error.message}`, key: 'protocol-load' })
      throw error
    }
  }
  
  async setVariant(variant) {
    message.loading({ content: `Loading variant: ${variant}`, key: 'variant-load' })
    try {
      await this.essCommand(`ess::load_system ${this.state.currentSystem} ${this.state.currentProtocol} ${variant}`)
      message.success({ content: `Variant loaded: ${variant}`, key: 'variant-load' })
    } catch (error) {
      message.error({ content: `Failed to load variant: ${error.message}`, key: 'variant-load' })
      throw error
    }
  }
  
  async startExperiment() {
    try {
      await this.essCommand('ess::start')
      message.success('Experiment started')
    } catch (error) {
      message.error(`Failed to start: ${error.message}`)
      throw error
    }
  }
  
  async stopExperiment() {
    try {
      await this.essCommand('ess::stop')
      message.warning('Experiment stopped')
    } catch (error) {
      message.error(`Failed to stop: ${error.message}`)
      throw error
    }
  }
  
  async resetExperiment() {
    try {
      await this.essCommand('ess::reset')
      message.info('Experiment reset')
    } catch (error) {
      message.error(`Failed to reset: ${error.message}`)
      throw error
    }
  }
  
  async setSubject(subject) {
    try {
      await this.essCommand(`ess::set_subject ${subject}`)
      message.success(`Subject set to ${subject}`)
    } catch (error) {
      message.error(`Failed to set subject: ${error.message}`)
      throw error
    }
  }
}

// Export singleton instance
export const dserv = new DservWebSocket()
