#
# Local camera commands - Updated for PPM-first approach
#

# Available commands:
#  start ?camera_id?           - Start camera streaming
#  stop                        - Stop camera streaming
#  check_status                - Get camera status
#  check_ring_buffer           - Get ring buffer status
#  get_frame_ppm frame_id      - Get frame as PPM data
#  get_frame_jpeg frame_id     - Get frame as JPEG data
#  save_frame frame_id file    - Save frame (.ppm/.jpg)
#  publish_frame frame_id datapoint ?format? - Publish frame

#
# can set desired resolution here and use below in start
#

# Define a callback function that will be called for each frame
proc my_frame_handler {frame_id timestamp_ms width height ppm_size ae_settled datapoint_prefix} {
    # Convert timestamp to readable format
    set timestamp_sec [expr $timestamp_ms / 1000]
    set datetime [clock format $timestamp_sec -format "%Y-%m-%d %H:%M:%S"]
    
    set info "Frame $frame_id at $datetime: ${width}x${height}, PPM size: $ppm_size bytes, AE settled: $ae_settled"

    dservSet $datapoint_prefix/frame_info $info
    cameraPublishPreviewFrame $frame_id $datapoint_prefix/preview
#    set PPM_TYPE 15
#    dservSetData $datapoint_prefix/preview [now] $PPM_TYPE [cameraGetPreviewFrame $frame_id ppm]
    
    # Publish as PPM (lossless, self-describing format)
    #set datapoint_name $datapoint_prefix/frame_ppm
    #if {[catch {cameraPublishPpmCallbackFrame $frame_id $datapoint_name} result]} {
    #    error "Error publishing PPM frame: $result"
    #    return
    #}
    
    # Can also publish as JPEG for bandwidth-sensitive clients
    # Uncomment if you want both formats available:
    # set jpeg_datapoint_name $datapoint_prefix/frame_jpeg
    # if {[catch {cameraPublishJpegCallbackFrame $frame_id $jpeg_datapoint_name} result]} {
    #     puts "Error publishing JPEG frame: $result"
    # }
    
    # Or save frame to disk (choose format)
    # Uncomment to save frames:
    # set filename "/tmp/frame_${frame_id}.ppm"
    # if {[catch {cameraSavePpmCallbackFrame $frame_id $filename} result]} {
    #     puts "Error saving PPM frame: $result"
    # }
}

# start streaming
proc start { { camera_id 0 } } {
   
    # Initialize camera
    if {[catch {cameraInit $camera_id} result]} {
        puts "Error initializing camera: $result"
        return
    }
    
    # Configure camera at native 1920x1080 30Hz preview 320x240
    if {[catch {cameraConfigure 1920 1080 30.0 320 240} result]} {
        puts "Error configuring camera: $result"
        return
    }

    #############################
    #      MANUAL SETTINGS      #
    #############################
    
    # Lock exposure
    #cameraSetAutoExposure 0
    #cameraSetExposureTime 15000
    #cameraSetAnalogGain 2.0

    # Lock white balance for consistent color
    #cameraSetAutoWhiteBalance 0
    # (green is always 1.0)
    #cameraSetRedGain 1.8
    #cameraSetBlueGain 1.5
    
    # Adjust sharpness
    #cameraSetSharpness 1.3

    # Start streaming
    if {[catch {cameraStartStreaming} result]} {
        puts "Error starting streaming: $result"
        return
    }

    cameraSetFrameSkipRate 30
    
    # Start continuous callback mode on every non skipped frame (1fps)
    if {[catch {cameraStartContinuousCallback my_frame_handler "camera" 1} result]} {
        puts "Error starting continuous callback: $result"
        return
    }
    
    dservSet camera/status continuous
    puts "Camera started in continuous mode - publishing PPM frames to dataserver"
}

# stop streaming
proc stop {} {
    dservSet camera/status stopped
    if {[catch {cameraStopContinuous} result]} {
        puts "Error stopping continuous mode: $result"
    } 
    if {[catch {cameraStopStreaming} result]} {
        puts "Error stopping streaming: $result"
    }
    puts "Camera stopped"
}

# Status check function
proc check_status {} {
    if {[catch {cameraStatus} status]} {
        puts "Error getting status: $status"
        return
    }
    return $status
}

proc check_ring_buffer {} {
    if {[catch {cameraGetRingBufferStatus} ring_status]} {
        puts "Error getting ring buffer status: $ring_status"
        return
    }
    return $ring_status
}

# New helper functions for working with the ring buffer

# Get a specific frame as PPM data
proc get_frame_ppm {frame_id} {
    if {[catch {cameraGetPpmCallbackFrame $frame_id} ppm_data]} {
        puts "Error getting PPM frame $frame_id: $ppm_data"
        return ""
    }
    return $ppm_data
}

# Get a specific frame as JPEG data (on-demand encoding)
proc get_frame_jpeg {frame_id} {
    if {[catch {cameraGetJpegCallbackFrame $frame_id} jpeg_data]} {
        puts "Error getting JPEG frame $frame_id: $jpeg_data"
        return ""
    }
    return $jpeg_data
}

# Save a specific frame from ring buffer
proc save_frame {frame_id filename} {
    # Determine format from filename extension
    set ext [string tolower [file extension $filename]]
    
    if {$ext eq ".ppm"} {
        if {[catch {cameraSavePpmCallbackFrame $frame_id $filename} result]} {
            puts "Error saving PPM frame: $result"
            return 0
        }
    } elseif {$ext eq ".jpg" || $ext eq ".jpeg"} {
        if {[catch {cameraSaveJpegCallbackFrame $frame_id $filename} result]} {
            puts "Error saving JPEG frame: $result"
            return 0
        }
    } else {
        puts "Unsupported file extension: $ext (use .ppm, .jpg, or .jpeg)"
        return 0
    }
    
    puts "Saved frame $frame_id to $filename"
    return 1
}

# Publish a specific frame from ring buffer to a custom datapoint
proc publish_frame {frame_id datapoint_name {format "ppm"}} {
    if {$format eq "ppm"} {
        if {[catch {cameraPublishPpmCallbackFrame $frame_id $datapoint_name} result]} {
            puts "Error publishing PPM frame: $result"
            return 0
        }
    } elseif {$format eq "jpeg"} {
        if {[catch {cameraPublishJpegCallbackFrame $frame_id $datapoint_name} result]} {
            puts "Error publishing JPEG frame: $result"
            return 0
        }
    } else {
        puts "Unsupported format: $format (use 'ppm' or 'jpeg')"
        return 0
    }
    
    puts "Published frame $frame_id as $format to $datapoint_name"
    return 1
}

